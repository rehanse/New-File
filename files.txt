import { Component } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormControl, FormControlStatus, FormGroup, Validators } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { catchError, debounceTime, distinctUntilChanged, of, Subscription, switchMap } from 'rxjs';
import { LoaderService } from '../../../../../core/services/loader/loader.service';
import { ReToolConstants } from '../../../constants/re-tool.constants';
import { ActionEnum } from '../../../models/action-enum';
import { FormDataSource } from '../../../models/form-data-source';
import { GridRowRecord } from '../../../models/grid-row-record';
import { LocationModel } from '../../../models/location';
import { LocationSearchResponseModel } from '../../../models/location-search-response-model';
import { PropertyValue } from '../../../models/property-value';
import { SubTabEncodedEnum } from '../../../models/re-tool-tabs-enum';
import { DeleteComponent } from '../../../popup/delete/delete.component';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { ReToolService } from '../../../service/re-tool.service';
import { MapperUtil, Utility } from '../../../utility/mapper-util';
import { LocationFilterModel } from '../../../../loc-address/models/location-name-address';
import { CountrySearchResponseModel } from '../../../models/country-search-respone-model';

@Component({
  selector: 're-tool-property-value',
  templateUrl: './property-value.component.html',
  styleUrl: './property-value.component.css'
})

export class PropertyValueComponent {
  propertyValueForm: FormGroup;
  private propertyValueData: PropertyValue[] = [];
  private previousFormStatus: FormControlStatus = ReToolConstants.valid;
  propertyValueDataSource: MatTableDataSource<AbstractControl>;
  propertyValueDisplayedColumns: string[] = [];
  subscription: Subscription | undefined = new Subscription();
  locationSearchKeyword = ReToolConstants.keywordDescription;
  locationData: LocationSearchResponseModel[] = [];
  locationModel: LocationModel;
  locationFilterRequestModel: LocationFilterModel;
  locationAddressPlaceholder = ReToolConstants.locationAddressPlaceholder;
  currenyUnitData: any = {};
  submitted: boolean = false;
  isValidLocation: boolean = true;
  actionEnum = ActionEnum;
  registeredAllSubscriptions: boolean = false;
  countrySearchKeyword = ReToolConstants.keywordCountrySearch;
  countryPlaceholder = ReToolConstants.countryPlaceholder;
  countryData: CountrySearchResponseModel[] = [];
  rowIndexValue: number;
  locAddressSelectedData: any = [];

  ngOnInit() {
    this.initializeForm();
    this.registerSubscribers();
    this.handleInputChange();
    this.handleCountryInputChange();
    this.reToolTabService.selectedLocAddressData$.subscribe((data) => {
      this.locAddressSelectedData = data;
    });
    this.reToolTabService.emit('onFormComponentInit', { encodedTabIndex: SubTabEncodedEnum.PropertyValue });
    this.reToolTabService.selectedLocAddressData$.subscribe((data) => {
      this.appendLocAddressPopupDataWithExistingPropertyValueData(data);
    });
  }

  constructor(private fb: FormBuilder, private reToolService: ReToolService, private reToolTabService: ReToolTabService, private dialog: MatDialog, private isLoading: LoaderService) { }

  initializeForm() {
    const onInitializePropertyValueData = this.reToolTabService.on('onInitializePropertyValueData').subscribe({
      next: (event: FormDataSource) => {
        if (event.data) {
          this.propertyValueDisplayedColumns = event?.columns;
          this.propertyValueData = event?.data;
          const isAnyRecordNotSaved = this.propertyValueData.some(x => x.Action !== ActionEnum.IsSaved);
          if (!isAnyRecordNotSaved) {
            this.propertyValueData = this.reToolTabService
              .mergePropertyValueData<PropertyValue>(this.propertyValueData);
          }
          this.propertyValueForm = this.fb.group({
            rows: this.fb.array([])
          });
          this.initializeDataSource();
          this.propertyValueDataSource = new MatTableDataSource(this.tableRowsControls);
          this.getCurrencyUnitPropertyMasterData();
          this.reToolTabService.hasFormChange$.next(false);
        }
      },
      error: (error) => { }
    });
    this.subscription?.add(onInitializePropertyValueData);
  }

  initializeDataSource() {
    const rows = this.getFormArray();
    this.propertyValueData?.forEach(data => {
      const row = this.createRow(data);
      this.calculateTotalPd(row);
      this.calculateTotalTE(row);
      this.calculateTotal(row);
      this.setupCalculationSubscribers(row);
      rows.push(row);
      this.actionStateChange(row);
    });
  }

  createRow(data: PropertyValue): FormGroup {
    return this.fb.group({
      ULId: new FormControl(data.ULId),
      PropertyLocationId: new FormControl(data.PropertyLocationId || null),
      Address: new FormControl({ value: data.Address || '', disabled: false }, [Validators.required]),
      City: new FormControl({ value: data.City || '', disabled: false }),
      Country: new FormControl({ value: data.Country || '', disabled: false }, [Validators.required]),
      LocationName: new FormControl({ value: data.LocationName || '', disabled: false }, [Validators.required]),
      StateProvince: new FormControl({ value: data.StateProvince || '', disabled: false }, [Validators.required]),
      BuildingValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.BuildingValue)) || '0.0'),
      EquipmentValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.EquipmentValue)) || '0.0'),
      InventoryValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.InventoryValue)) || '0.0'),
      OtherValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.OtherValue)) || '0.0'),
      TotalPD: new FormControl({ value: data.TotalPD || '0.0', disabled: true }),
      BusinessInterruptionValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.BusinessInterruptionValue)) || '0.0'),
      BusinessInterruptionOtherValue: new FormControl(Utility.formatNumber(Utility.removeComma(data.BusinessInterruptionOtherValue)) || '0.0'),
      IndemnityPeriod: new FormControl(data.IndemnityPeriod || '0', Validators.required),
      PayRollValue: new FormControl(data.PayRollValue || '0.0'),
      PayRollDayValue: new FormControl(data.PayRollDayValue || '0'),
      TotalTE: new FormControl({ value: data.TotalTE || '0.0', disabled: true }),
      Total: new FormControl({ value: data.Total || '0.0', disabled: true }),
      Action: new FormControl(data.Action || ActionEnum.IsSaved),
      StreetAddressToolTip: new FormControl(data.StreetAddressToolTip),
      CityNamesToolTip: new FormControl(data.CityNamesToolTip),
      StateNamesToolTip: new FormControl(data.StateNamesToolTip),
      StreetAddresses: new FormControl(data['StreetAddresses']),
      CityNames: new FormControl(data['CityNames']),
      StateProvinces: new FormControl(data['StateProvinces']),
      LocationAddressMapIds: new FormControl(data.LocationAddressMapIds),
      LocationAddressMapId: new FormControl(data.LocationAddressMapId),
      CountryNotFound: new FormControl(data.CountryNotFound),
    });
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return this.reToolService.generateFormElementIdAttribute(rowIndex, dataId, columnName);
  }

  addNewLocation() {
    this.propertyValueForm.markAllAsTouched();
    this.submitted = false;

    if (this.propertyValueForm.status == ReToolConstants.invalid) {
      this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
    }

    const rows = this.getFormArray();
    const row = this.createRow(new PropertyValue());
    this.setupCalculationSubscribers(row);
    rows.push(row);
    this.propertyValueDataSource.data = this.tableRowsControls;
    this.reToolTabService.hasFormChange$.next(true);
    const formdata: FormDataSource = new FormDataSource
      (
        this.getFormArray().value as PropertyValue[], {}
      );
  }

  getCurrencyUnitPropertyMasterData() {
    this.reToolService.currencyUnit$.subscribe(({
      next: (data) => {
        if (data !== undefined && data !== null) {
          this.currenyUnitData.currencyType = data;
          this.currenyUnitData.unitType = data;
        }
      },
      error: (error) => {
        throw new error;
      }
    }));
  }

  onCellValueChange(event: Event, column: FormControl) {
    const cellElement = event.target as HTMLElement;
    const response: GridRowRecord = this.getGidRowRecordDetail(cellElement?.id);
    response.value = column.value;
    this.updatePatchRow(response.rowIndex, response.columnName, response.value);
  }

  delete(rowIndex: number) {
    this.dialog.open(DeleteComponent).afterClosed().subscribe(dialogRes => {

      if (dialogRes == true) {
        const row = this.getFormGroup(rowIndex);
        const action = row.get('Action').value;

        if (action == ActionEnum.IsNewRecord) {
          this.getFormArray().removeAt(rowIndex);
          this.propertyValueDataSource = new MatTableDataSource(this.tableRowsControls);
        }
        else {
          this.getFormGroup(rowIndex)
            .patchValue({
              CountryNotFound: false,
              Action: ActionEnum.IsDeleted
            });
          this.setActionChanges();
        }
      }
    });
  }

  processExcelData(jsonData: any[], propertyValueData: any[]) {
    const mergedRecords: any = {};

    this.clearImportData();

    jsonData.forEach((row, index) => {
      const key = `${row.locationName}_${row.locationAddress}_${row.city}_${row.state}_${row.country}`;
      const propertyValueRow = propertyValueData.filter((x, propertyIndex) => `${x.LocationName}_${x.Address}_${x.City}_${x.StateProvince}_${x.Country}`?.toLowerCase() === key?.toLowerCase() && index === propertyIndex);
      const propertyValue = MapperUtil.mapRowToPropertyValueExcelFile(propertyValueRow, row);

      if (!propertyValue.ULId) {
        // find the existing record based on Location Name and Country Name
        const existingKey = this.findMatchingRecordKey(mergedRecords, propertyValue.LocationName, propertyValue.Country);
        if (existingKey) {
          this.mergeValues(mergedRecords, existingKey, propertyValue);
          return;
        }
      } else {
        //If ULID exists handle merging for already saved records or new records based on ULID, Location Name and CountryName key combination
        const locationKey = Utility.getLocationKeyCombination(propertyValue.ULId, propertyValue.LocationName, propertyValue.Country);
        // if the record is saved, update the existing one otherwise create a new entry
        if (mergedRecords[locationKey]) {
          this.mergeValues(mergedRecords, locationKey, propertyValue);
        } else {
          // if no record exist then create a new row
          mergedRecords[locationKey] = {
            ...propertyValue,
            StreetAddresses: [propertyValue.Address],
            CityNames: [propertyValue.City],
            StateProvinces: [propertyValue.StateProvince]
          };
        }
      }
    });

    const mergedDataArray = Object.values(mergedRecords);

    this.mergeImportedAndExistingPropertyValueData(mergedDataArray as PropertyValue[]);
    this.reToolTabService.hasFormChange$.next(true);
    this.isLoading.setLoaderStatus(false);
  }

  get tableRowsControls() {
    return this.getFormArray().controls;
  }

  locationChange(value: string) {
    this.isValidLocation = false;
    this.locationFilterRequestModel = {
      LocationAddress: '',
      LocationName: value,
      PageIndex: 0,
      PageSize: 1000
    };
    this.reToolService.locationApiDataSubscribe$.next(this.locationFilterRequestModel);
  }

  locationSelected(model: LocationSearchResponseModel, rowIndex: number) {
    const modelLocation: LocationModel = {
      ULID: model.ulid,
      LocationName: model.description,
      Address: '',
      City: '',
      StateProvince: '',
      Country: '',
      VerCol: ''
    };
    this.locationModel = modelLocation;
    this.updateLocationAssociatedColumns(rowIndex, this.locationModel);
    if (this.locationModel.LocationName != null) {
      this.isValidLocation = true;
    }

  }

  locationCleared(rowIndex: number) {
    this.updateLocationAssociatedColumns(rowIndex, {} as LocationModel);
  }

  countryCleared(rowIndex: number) {
    const row = this.getFormGroup(rowIndex);
    row.patchValue({
      Country: '',
      Action: (row.get('Action').value == ActionEnum.IsNewRecord
        ? ActionEnum.IsNewRecord
        : ActionEnum.IsModified)
    });
  }

  countryChanged(value: string, rowIndex: number) {
    if (value != '') {
      this.rowIndexValue = rowIndex;
      this.reToolService.countrySearchSubject$.next(value);
    }
  }

  countrySelected(event, rowIndex: number) {
    const row = this.getFormGroup(rowIndex);
    row.patchValue({
      CountryNotFound: false,
      Country: event.countryName || '',
      Action: (row.get('Action').value == ActionEnum.IsNewRecord
        ? ActionEnum.IsNewRecord
        : ActionEnum.IsModified)
    });
  }

  setToolTipValues(currentControl: any, setControl: any, controlvalue: any, rowIndex: number) {
    const row = this.getFormGroup(rowIndex);
    const formControlNameValue = row.get(currentControl).value;
    let toolTips = row.get(setControl).value || [];

    if (formControlNameValue !== ReToolConstants.multiple && Array.isArray(toolTips)) {
      toolTips.push(controlvalue);
      row.get(setControl).setValue(toolTips[0]);
    }
  }

  private registerSubscribers() {
    this.subscription?.add(
      this.reToolService.importData$.subscribe(data => {
        if (data && data.locationData.length > 0 && data.propertyValueData.length > 0 && (data.locationData.length === data.propertyValueData.length)) {
          this.processExcelData(data.locationData, data.propertyValueData);
        }
      }));

    this.subscription?.add(
      this.reToolService.addNewLocation$.subscribe(() => {
        this.addNewLocation();
      }));

    this.subscription?.add(
      this.reToolTabService.on('onProcessingSave').subscribe((event) => {
        this.propertyValueForm.markAllAsTouched();
        this.propertyValueForm.markAsPristine();
        this.propertyValueForm.updateValueAndValidity();
        this.reToolTabService.formStatus = this.propertyValueForm.status;
        const countyNotFound = this.getPropertyValueFormData.some(item => item.CountryNotFound);

        const hasFormError = this.propertyValueForm.status === ReToolConstants.invalid;
        this.reToolTabService.emit('onValidateCurrencyAndUnit', null);
        const hasCurrencyAndUnitError = !this.reToolTabService.currencyUnitValid;

        if (hasFormError || hasCurrencyAndUnitError || countyNotFound) {
          this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
        } else {
          this.reToolTabService.emit('onSaveFormData', { formData: this.getPropertyValueFormData, subTabIndex: 0, tabInfo: event?.tabInfo, isTabChange: event?.isTabChange });
        }
      }));

    this.subscription?.add(
      this.propertyValueForm?.statusChanges.subscribe((status) => {
        if (status !== this.previousFormStatus) {
          this.previousFormStatus = this.propertyValueForm.status;
          this.reToolTabService.formStatus = this.propertyValueForm.status;
        }
      })
    );

    this.registeredAllSubscriptions = true;
  }

  private get getPropertyValueFormData(): PropertyValue[] {
    return this.getFormArray()?.value as PropertyValue[];
  }

  private handleInputChange(): void {
    const autoCompleteInputChange = this.reToolService.locationApiDataSubscribe$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => this.reToolService.searchLocationByName(value).pipe(
        catchError(err => { return of([]) })
      ))
    )
      .subscribe({
        next: (response: any) => {
          this.locationData = response.map((res) => {
            return {
              ulid: res.ulid,
              description: res.locationName
            } as LocationSearchResponseModel;
          });
        },
        error: (error) => { }
      })

    this.subscription?.add(autoCompleteInputChange);
  }

  private getFormArray(): FormArray {
    return (this.propertyValueForm.get('rows') as FormArray);
  }

  private setUpPropertyDamagedIndexTotalCalculation(row: FormGroup<any>) {
    const buildingValue = row.get('BuildingValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalPd(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(buildingValue);

    const equipmentValue = row.get('EquipmentValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalPd(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(equipmentValue);

    const inventoryValue = row.get('InventoryValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalPd(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(inventoryValue);

    const otherValue = row.get('OtherValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalPd(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(otherValue);
  }

  private calculateTotalPd(row: FormGroup<any>) {
    const buildingValue = parseFloat(Utility.removeComma(row.get('BuildingValue')?.value)) || 0.0;
    const equipmentValue = parseFloat(Utility.removeComma(row.get('EquipmentValue')?.value)) || 0.0;
    const inventoryValue = parseFloat(Utility.removeComma(row.get('InventoryValue')?.value)) || 0.0;
    const otherValue = parseFloat(Utility.removeComma(row.get('OtherValue')?.value)) || 0.0;
    const totalPD = buildingValue + equipmentValue + inventoryValue + otherValue;
    row.get('TotalPD').setValue(Utility.commaSepratedValueForDisabledInput(totalPD), { emitEvent: false });
    this.calculateTotal(row);
  }

  private setUpTimeElementTotalCalculation(row: FormGroup<any>) {
    const businessInterruptionValue = row.get('BusinessInterruptionValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalTE(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));

    this.subscription?.add(businessInterruptionValue);

    const businessInterruptionOtherValue = row.get('BusinessInterruptionOtherValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalTE(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));

    this.subscription?.add(businessInterruptionOtherValue);

    const payrollValue = row.get('PayRollValue')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotalTE(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));

    this.subscription?.add(payrollValue);
  }

  private calculateTotalTE(row: FormGroup<any>) {
    const businessInterruptionValue = parseFloat(Utility.removeComma(row.get('BusinessInterruptionValue')?.value)) || 0.0;
    const businessInterruptionOtherValue = parseFloat(Utility.removeComma(row.get('BusinessInterruptionOtherValue')?.value)) || 0.0;
    const payRollValue = parseFloat(Utility.removeComma(row.get('PayRollValue')?.value)) || 0.0;
    const totalTE = businessInterruptionValue + businessInterruptionOtherValue + payRollValue;
    row.get('TotalTE').setValue(Utility.commaSepratedValueForDisabledInput(totalTE), { emitEvent: false });
    this.calculateTotal(row);
  }

  private setUpTotalCalculation(row: FormGroup<any>) {

    const totalPD = row.get('TotalPD')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotal(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(totalPD);

    const totalTE = row.get('TotalTE')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotal(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(totalTE);
  }

  private calculateTotal(row: FormGroup<any>) {
    const totalPDValue = parseFloat(Utility.removeComma(row.get('TotalPD')?.value)) || 0.0;
    const totalTEValue = parseFloat(Utility.removeComma(row.get('TotalTE')?.value)) || 0.0;
    const total = totalPDValue + totalTEValue;
    row.get('Total').setValue(Utility.commaSepratedValueForDisabledInput(total), { emitEvent: false });
  }

  private getFormGroup(rowIndex: number): FormGroup {
    return (this.getFormArray()
      .at(rowIndex) as FormGroup);
  }

  private getGidRowRecordDetail(input: string): GridRowRecord {

    const [rowPart, idPart, column, popup] = input.split('_');

    const record: GridRowRecord = {
      rowIndex: parseInt(rowPart.split('-')[1]),
      columnName: column,
      rowPKId: parseInt(idPart.split('-')[1]),
      value: '',
      popup: popup
    };

    return record;
  }

  private updatePatchRow(rowIndex: number, column: string, value: string) {
    const row = this.getFormGroup(rowIndex);
    row.patchValue({
      [column]: value,
      ['Action']: (row.get('Action').value == ActionEnum.IsNewRecord
        ? ActionEnum.IsNewRecord
        : ActionEnum.IsModified)
    });
  }

  private setupCalculationSubscribers(row: FormGroup<any>) {
    this.setUpPropertyDamagedIndexTotalCalculation(row);
    this.setUpTimeElementTotalCalculation(row);
    this.setUpTotalCalculation(row);
  }

  private actionStateChange(row: FormGroup) {
    this.subscription?.add(
      row?.get('Action').valueChanges.subscribe(value => {
        this.reToolTabService.hasFormChange$.next((value != ActionEnum.IsSaved))
      })
    );
  }

  private setActionChanges() {
    const rows = this.getPropertyValueFormData.filter(property =>
      property.Action == ActionEnum.IsNewRecord
      || property.Action == ActionEnum.IsDeleted
      || property.Action == ActionEnum.IsModified
    );
    this.reToolTabService.hasFormChange$.next((rows.length > 0 ? true : false));
  }

  private locationExist(rowIndex: number, addresslocation: string) {
    const row = this.getFormGroup(rowIndex);
    row.patchValue({
      LocationName: addresslocation,
      CountryName: '',
      CityName: '',
      StateName: '',
      Location: {},
      Action: (row.get('Action').value == ActionEnum.IsNewRecord
        ? ActionEnum.IsNewRecord
        : ActionEnum.IsModified)
    });
  }

  private mergeValues(mergedRecords: any, recordKey: string, propertyValue: PropertyValue) {
    const existingRecord = mergedRecords[recordKey];
    existingRecord.BuildingValue += parseFloat(Utility.removeComma(propertyValue.BuildingValue));
    existingRecord.EquipmentValue += parseFloat(Utility.removeComma(propertyValue.EquipmentValue)); 
    existingRecord.InventoryValue += parseFloat(Utility.removeComma(propertyValue.InventoryValue)); 
    existingRecord.OtherValue += parseFloat(Utility.removeComma(propertyValue.OtherValue)); 
    existingRecord.BusinessInterruptionValue += parseFloat(Utility.removeComma(propertyValue.BusinessInterruptionValue)); 
    existingRecord.BusinessInterruptionOtherValue += parseFloat(Utility.removeComma(propertyValue.BusinessInterruptionOtherValue)); 
    existingRecord.PayRollValue += parseFloat(Utility.removeComma(propertyValue.PayRollValue)); 
   
    // handle multiple street addresses and tooltip
    if (existingRecord.StreetAddresses) {
      existingRecord.StreetAddresses.push(propertyValue.Address);
    }
    // handle multiple city and tooltip
    if (existingRecord.CityNames) {
      existingRecord.CityNames.push(propertyValue.City);
    }
    // handle multiple states and tooltip
    if (existingRecord.StateProvinces) {
      existingRecord.StateProvinces.push(propertyValue.StateProvince);
    }

    if (propertyValue.LocationAddressMapId !== null && propertyValue.LocationAddressMapId > 0) {
      existingRecord.LocationAddressMapIds.push(existingRecord.LocationAddressMapId);
      existingRecord.LocationAddressMapIds.push(propertyValue.LocationAddressMapId);
      existingRecord.LocationAddressMapIds = Array.from(new Set(existingRecord.LocationAddressMapIds));
    }
  }

  private findMatchingRecordKey(mergedRecords: any, fullAddress: string, countryName: string): string | null {
    for (const key in mergedRecords) {
      if (mergedRecords.hasOwnProperty(key)) {
        const [ULId, storedFullAddress, storedCountryName] = key.split('_');
        if (storedFullAddress === fullAddress && storedCountryName === countryName) {
          return key;
        }
      }
    }
    return null;
  }

  private clearImportData() {
    const rows = this.getFormArray();
    // only remove rows where the Action is new record
    for (let i = rows.length - 1; i >= 0; i--) {
      const formGroup = this.getFormGroup(i);
      const action = formGroup.get('Action')?.value;
      if (action === ActionEnum.IsNewRecord) {
        rows.removeAt(i);
      }
    }
  }

  private compareImportedWithExistindRecords(propertyValues: PropertyValue[], importedRecords: PropertyValue[]): any {
    const importedRecordsSet = new Set(importedRecords.map(pl => pl.ULId));
    const propertyValuesSet = new Set(propertyValues.map(pl => pl.ULId));
    const newRecords: PropertyValue[] = importedRecords.filter((x) => !propertyValuesSet.has(x.ULId));
    const unmatchedRecords: PropertyValue[] = propertyValues.filter((x) => !importedRecordsSet.has(x.ULId));
    const matchedRecords: PropertyValue[] = importedRecords.filter((x) => propertyValuesSet.has(x.ULId));
    return { matchedRecords, unmatchedRecords, newRecords };
  }

  private updateAndDeleteImportedWithExistingRecords(pvFormValues: PropertyValue[], importedRecords: PropertyValue[], isImportWithPropertyValueFormMerge: boolean): PropertyValue[] {
    const { matchedRecords, unmatchedRecords, newRecords } = this.compareImportedWithExistindRecords(pvFormValues, importedRecords);

    unmatchedRecords?.forEach(pv => pv.Action = ActionEnum.IsDeleted);
    newRecords?.forEach(pv => pv.Action = ActionEnum.IsNewRecord);

    let valuesToBeMerged: PropertyValue[] = [];
    matchedRecords?.forEach(imported => {
      pvFormValues?.forEach(pv => {
        if (pv.ULId === imported.ULId) {
          imported.PropertyLocationId = pv.PropertyLocationId;
          (pv as any).CityNames = [];
          (pv as any).StreetAddresses = [];
          (pv as any).StateProvinces = [];
          pv.LocationAddressMapId = 0;
          pv.LocationAddressMapIds = imported.LocationAddressMapIds;
          pv.Action = ActionEnum.IsModified;
          valuesToBeMerged.push(pv);

          let rowIndex = this.getFormArray()
            .controls
            .findIndex(control => control.get('ULId')?.value === pv.ULId);
          if (rowIndex > -1) {
            this.getFormArray().removeAt(rowIndex);
            this.propertyValueDataSource = new MatTableDataSource(this.tableRowsControls);
          }
        }
      });
    });

    if (matchedRecords.length > 0
      || valuesToBeMerged.length > 0
      || newRecords.length > 0) {
      isImportWithPropertyValueFormMerge = true;
      return [...matchedRecords, ...valuesToBeMerged, ...newRecords, ...unmatchedRecords];
    }
    else
      return [...pvFormValues, ...importedRecords];
  }

  private mergeImportedAndExistingPropertyValueData(importedPropertyValues: PropertyValue[]): void {
    const pVFormValues = this.getPropertyValueFormData;
    let isImportWithPropertyValueFormMerge: boolean = false;
    const propertyValues: PropertyValue[]
      = this.updateAndDeleteImportedWithExistingRecords
        (
          pVFormValues,
          importedPropertyValues,
          isImportWithPropertyValueFormMerge
        );
    const mergedData = this.mergePropertyValueAndAddresses(propertyValues, false);
    mergedData.forEach(x => this.reToolTabService.setAddressAndToolTip(x));
    if (isImportWithPropertyValueFormMerge) {
      mergedData.forEach(x => this.createRowsFromExcel(x));
    }
    else
      this.reinitializeDataSource(mergedData);
  }

  private reinitializeDataSource(propertyValues: PropertyValue[]) {
    const formDs: FormDataSource = new FormDataSource
      (
        propertyValues,
        this.reToolTabService.propertyLocationColumns
      );
    this.reToolTabService.emit('onInitializePropertyValueData', formDs);
  }

  private createRowsFromExcel(propertyValue: PropertyValue) {
    const rows = this.getFormArray();
    const rowData = this.createRow(propertyValue);
    this.calculateTotalPd(rowData);
    this.calculateTotalTE(rowData);
    this.calculateTotal(rowData);
    this.setupCalculationSubscribers(rowData);
    rows.push(rowData);
    this.actionStateChange(rowData);
  }

  private appendLocAddressPopupDataWithExistingPropertyValueData(locAddressPopupData: PropertyValue[]): void {
    const mappedPopupData: any = locAddressPopupData?.map(x => MapperUtil.normalizeLocAddressPopupData(x));
    
    if(!Array.isArray(mappedPopupData)){
      return;
    }

    let propertyValues = [...this.getPropertyValueFormData, ...mappedPopupData];
    const mergedData = this.mergePropertyValueAndAddresses(propertyValues, true);
    mergedData.forEach(x => this.reToolTabService.setAddressAndToolTip(x));
    this.reToolTabService.setLocAddressPopupClosedSubject(true);
    this.reinitializeDataSource(mergedData);
    this.reToolTabService.hasFormChange$.next(true);
  }

  private mergePropertyValueAndAddresses(propertyValues: PropertyValue[], isFromLocAddressPopup: boolean = false): any {
    const mergeMap = new Map<string, {}>();
    propertyValues.forEach(item => {
      if (item.ULId === ReToolConstants.blank
                && item.Country === ReToolConstants.blank
                && item.LocationName === ReToolConstants.blank) {
        this.clearImportData();
        return;
      }

      const key = item.ULId;
      if (!mergeMap.has(key) && item.Action !== ActionEnum.IsDeleted) {
        if (item.LocationAddressMapId !== null
          && item.LocationAddressMapId > 0
          && (item.LocationAddressMapIds === null
            || item.LocationAddressMapIds.length === 0)
          && !item.LocationAddressMapIds?.includes(item.LocationAddressMapId)) {
          item.LocationAddressMapIds.push(item.LocationAddressMapId);
        }
        mergeMap.set(key, { ...item, StreetAddresses: [item['StreetAddresses']].flat(), CityNames: [item['CityNames']].flat(), StateProvinces: [item['StateProvinces']].flat() });
      }
      else if (mergeMap.has(key) && item.Action !== ActionEnum.IsDeleted) {
        let existing = mergeMap.get(key);
        existing['StreetAddresses'] = Array.from([...existing['StreetAddresses'], ...item['StreetAddresses']]);
        existing['CityNames'] = Array.from([...existing['CityNames'], ...item['CityNames']]);
        existing['StateProvinces'] = Array.from([...existing['StateProvinces'], ...item['StateProvinces']]);
        existing['BuildingValue'] =
          parseFloat(Utility.removeComma(existing['BuildingValue']))
          + parseFloat(Utility.removeComma(item.BuildingValue))
        existing['EquipmentValue'] =
          parseFloat(Utility.removeComma(existing['EquipmentValue']))
          + parseFloat(Utility.removeComma(item.EquipmentValue));
        existing['InventoryValue'] =
          parseFloat(Utility.removeComma(existing['InventoryValue']))
          + parseFloat(Utility.removeComma(item.InventoryValue));
        existing['OtherValue'] =
          parseFloat(Utility.removeComma(existing['OtherValue']))
          + parseFloat(Utility.removeComma(item.OtherValue));
        existing['BusinessInterruptionValue'] =
          parseFloat(Utility.removeComma(existing['BusinessInterruptionValue']))
          + parseFloat(Utility.removeComma(item.BusinessInterruptionValue));
        existing['BusinessInterruptionOtherValue'] =
          parseFloat(Utility.removeComma(existing['BusinessInterruptionOtherValue']))
          + parseFloat(Utility.removeComma(item.BusinessInterruptionOtherValue));
        existing['PayRollValue'] =
          parseFloat(Utility.removeComma(existing['PayRollValue']))
          + parseFloat(Utility.removeComma(item.PayRollValue));

        if (item.LocationAddressMapId !== null && item.LocationAddressMapId > 0) {
          if (item.LocationAddressMapIds != null && item.LocationAddressMapIds.length > 0)
            existing['LocationAddressMapIds'] = Array.from(new Set([...existing['LocationAddressMapIds'], ...item.LocationAddressMapIds]));
          else if (!existing['LocationAddressMapIds']?.includes(item.LocationAddressMapId))
            existing['LocationAddressMapIds'].push(item.LocationAddressMapId);
        }

        existing['LocationAddressMapIds'] = existing['LocationAddressMapIds']?.filter(val => Number(val) !== 0);
        existing['Action'] = ActionEnum.IsModified;
      }
      else {
        let propertyValue = new PropertyValue();
        propertyValue.ULId = item.ULId;
        propertyValue.PropertyLocationId = item.PropertyLocationId;
        propertyValue.LocationName = item.LocationName;
        propertyValue.Country = item.Country;
        propertyValue.LocationAddressMapIds = [];
        mergeMap.set(key, { ...propertyValue, StreetAddresses: [], CityNames: [], StateProvinces: [] });
      }
    });
    return Array.from(mergeMap.values());
  }

  private handleCountryInputChange(): void {
    const autoCompleteInputChange = this.reToolService.countrySearchSubject$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => this.reToolService.searchCountryName(value).pipe(
        catchError(err => { return of([]) })
      ))
    )
      .subscribe({
        next: (response: any) => {
          const row = this.getFormGroup(this.rowIndexValue);

          if (response.length > 0) {
            this.countryData = response.map((res) => {
              return {
                countryId: res.countryId,
                countryName: res.countryName
              } as CountrySearchResponseModel;
            });
            row.get('CountryNotFound').setValue(false);
          }
          else {
            row.get('CountryNotFound').setValue(true);
          }
        },
        error: (error) => { }
      })

    this.subscription?.add(autoCompleteInputChange);
  }

  private updateLocationAssociatedColumns(rowIndex: number, location: LocationModel) {
    const row = this.getFormGroup(rowIndex);
    row.patchValue({
      LocationName: location?.LocationName || '',
      ULId: location?.ULID || '',
      Action: (row.get('Action').value == ActionEnum.IsNewRecord
        ? ActionEnum.IsNewRecord
        : ActionEnum.IsModified)
    });
  }

  ngOnDestroy() {
    this.subscription?.unsubscribe();
    this.reToolTabService.emit('onComponentDestroy', { isValid: this.propertyValueForm?.valid });
  }
}
----------------------------------------------------------------------------------------------
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class LoaderService {
  private loading: boolean = false;

  constructor() {}

  setLoaderStatus(isLoaderActive: boolean) {
    this.loading = isLoaderActive;
  }

  getLoaderStatus(): boolean {
    return this.loading;
  }
}
-----------------------------------------
import { ActionEnum } from "./action-enum";
import { BaseTabModel } from "./base-tab-model";

export class PropertyValue implements BaseTabModel {
    ULId?: string = '';
    PropertyLocationId?: number = 0;
    CurrencyId: number = 0;
    UnitId: number = 0;
    BuildingValue: number = 0.0;
    EquipmentValue: number = 0.0;
    InventoryValue: number = 0.0;
    OtherValue: number = 0.0;
    TotalPD?: number = 0.0;
    BusinessInterruptionValue: number = 0.0;
    BusinessInterruptionOtherValue: number = 0.0;
    IndemnityPeriod: number = 0.0;
    PayRollValue: number = 0.0;
    PayRollDayValue: number = 0.0;
    TotalTE: number = 0.0;
    Total: number = 0.0;
    Address: string = '';
    City: string = '';
    Country: string = '';
    LocationName: string = '';
    StateProvince: string = '';
    Action: ActionEnum = ActionEnum.IsNewRecord;
    VerCol: '';
    StreetAddressToolTip?: any = [];
    CityNamesToolTip?: any = [];
    StateNamesToolTip?: any = [];
    UAID?: string = '';
    CountryId: number = 0;
    AddressId: number = 0;
    LocationAddressMapId: number = 0;
    LocationAddressMapIds: number[] = [];
    CountryNotFound: boolean;
}
--------------------------------------------------------
16 specs, 3 failures, randomized with seed 08656
Spec List | Failures
PropertyValueComponent > should process excel data and merge records when matching record is found
TypeError: Cannot read properties of undefined (reading 'next')
    at UserContext.apply (http://localhost:9876/_karma_webpack_/webpack:/src/app/features/re-tool/components/tab-component/property-value/property-value.component.spec.ts:241:13)
    at _ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:368:26)
    at ProxyZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:273:39)
    at _ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:367:52)
    at Zone.run (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:129:43)
    at runInTestZone (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:555:34)
    at UserContext.<anonymous> (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:570:20)
    at <Jasmine>
PropertyValueComponent > should create new records when no matching record is found
Expected undefined to be defined.
    at <Jasmine>
    at UserContext.apply (http://localhost:9876/_karma_webpack_/webpack:/src/app/features/re-tool/components/tab-component/property-value/property-value.component.spec.ts:268:47)
    at _ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:368:26)
    at ProxyZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:273:39)
    at _ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:367:52)
PropertyValueComponent > should handle ULID and update existing records correctly
Expected spy mockMergeValues to have been called with:
  [ Object({ ULID: '001-8989898', locationName: 'Indiana', locationAddress: '2 Park Avenue', city: 'New York', state: 'New York', country: 'United States' }), '001-8989898_Indiana_UnitedStates', Object({ ULID: '001-8989898', locationName: 'Indiana', locationAddress: '2 Park Avenue', city: 'New York', state: 'New York', country: 'United States' }) ]
but it was never called.
    at <Jasmine>
    at UserContext.apply (http://localhost:9876/_karma_webpack_/webpack:/src/app/features/re-tool/components/tab-component/property-value/property-value.component.spec.ts:284:29)
    at UserContext.apply (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:1987:30)
    at _ZoneDelegate.invoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone.js:368:26)
    at ProxyZoneSpec.onInvoke (http://localhost:9876/_karma_webpack_/webpack:/node_modules/zone.js/fesm2015/zone-testing.js:273:39)
