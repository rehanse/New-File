import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { NormalLossExpectancyComponent } from './normal-loss-expectancy.component';
import { FormArray, FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { ReToolService } from '../../../service/re-tool.service';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { ReToolAddressGroupingService } from '../../../service/re-tool-address-grouping.service';
import { NormalLossExpectancy } from '../../../models/normal-loss-expectancy';
import { MatTableModule } from '@angular/material/table';
import { Subscription, of } from 'rxjs';
import { ActionEnum } from '../../../models/action-enum';
import { Utility } from '../../../utility/mapper-util';

describe('NormalLossExpectancyComponent', () => {
  let component: NormalLossExpectancyComponent;
  let fixture: ComponentFixture<NormalLossExpectancyComponent>;
  let fb: FormBuilder;
  let mockReToolTabService: jasmine.SpyObj<ReToolTabService>;
  let mockReToolService: jasmine.SpyObj<ReToolService>;
  let mockAddressGroupingService: jasmine.SpyObj<ReToolAddressGroupingService>;

  const mockNormalLossData: NormalLossExpectancy[] = [{
    LocationId: 1,
    Address: 'Test Address',
    LocationName: 'Test Location',
    ULId: 'UL123',
    Country: 'Test Country',
    NormalLossPropertyDamage: 1000,
    NormalLossOtherPropertyDamage: 500,
    NormalLossBusinessInterruption: 2000,
    NormalLossInterBusinessInterruption: 1000,
    NormalLossOtherTimeElement: 500,
    Action: ActionEnum.IsSaved
  } as NormalLossExpectancy];

  beforeEach(async () => {
    mockReToolTabService = jasmine.createSpyObj('ReToolTabService', ['on', 'emit', 'showErrorMessage']);
    mockReToolService = jasmine.createSpyObj('ReToolService', ['generateFormElementIdAttribute']);
    mockAddressGroupingService = jasmine.createSpyObj('ReToolAddressGroupingService', ['addressGroupingData']);

    await TestBed.configureTestingModule({
      imports: [ReactiveFormsModule, MatTableModule],
      declarations: [NormalLossExpectancyComponent],
      providers: [
        FormBuilder,
        { provide: ReToolTabService, useValue: mockReToolTabService },
        { provide: ReToolService, useValue: mockReToolService },
        { provide: ReToolAddressGroupingService, useValue: mockAddressGroupingService }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(NormalLossExpectancyComponent);
    component = fixture.componentInstance;
    fb = TestBed.inject(FormBuilder);
    
    mockReToolTabService.on.and.returnValue(of({}));
    mockReToolService.generateFormElementIdAttribute.and.returnValue('test-id');
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  describe('ngOnInit', () => {
    it('should initialize form and emit component init event', () => {
      component.ngOnInit();
      expect(mockReToolTabService.emit).toHaveBeenCalledWith('onFormComponentInit', jasmine.any(Object));
      expect(component.normalLossExpectancyForm).toBeDefined();
    });
  });

  describe('initializeForm', () => {
    it('should handle data initialization event', () => {
      const testData = { data: mockNormalLossData, columns: ['test'] };
      mockReToolTabService.on.and.callFake((eventName: string) => {
        if (eventName === 'onInitializeNormmalLossExpectancyData') {
          return of(testData);
        }
        return of({});
      });

      component.initializeForm();
      expect(component.normmalLossExpectancyData.length).toBe(1);
      expect(component.normmalLossExpectancyDataSource).toBeDefined();
    });
  });

  describe('Form Interactions', () => {
    beforeEach(() => {
      component.normalLossExpectancyForm = fb.group({
        rows: fb.array([component.createRow(mockNormalLossData[0])])
      });
    });

    it('should create row with correct form structure', () => {
      const row = component.createRow(mockNormalLossData[0]);
      expect(row.get('LocationName').value).toBe('Test Location');
      expect(row.get('NormalLossScenario').validator).toBe(Validators.required);
    });

    it('should update totals when values change', fakeAsync(() => {
      const row = (component.normalLossExpectancyForm.get('rows') as FormArray).at(0) as FormGroup;
      row.get('NormalLossPropertyDamage').setValue('2000');
      tick();
      expect(row.get('TotalPDNLE').value).toBe(Utility.commaSepratedValueForDisabledInput(2500));
    }));

    it('should handle invalid form submission', () => {
      component.onSubmit();
      expect(mockReToolTabService.showErrorMessage).toHaveBeenCalled();
    });
  });

  describe('Private Methods', () => {
    it('should calculate TotalPDNLE correctly', () => {
      const result = (component as any).calculateTotalPDNLE(1000, 500);
      expect(result).toBe(1500);
    });

    it('should calculate TotalTE correctly', () => {
      const result = (component as any).calculateTotalTE(2000, 1000, 500);
      expect(result).toBe(3500);
    });

    it('should update IPFactTotal when BI value changes', () => {
      const row = component.createRow(mockNormalLossData[0]);
      row.get('NormalLossIndemnityPeriodBI').setValue('5000');
      (component as any).calculateIPFactTotal(row);
      expect(row.get('IPFactTotal').value).toContain('3500');
    });
  });

  describe('Lifecycle Hooks', () => {
    it('should unsubscribe on destroy', () => {
      component.subscription = new Subscription();
      spyOn(component.subscription, 'unsubscribe');
      component.ngOnDestroy();
      expect(component.subscription.unsubscribe).toHaveBeenCalled();
    });
  });

  describe('Column Visibility', () => {
    it('should toggle columns visibility', () => {
      component.normmalLossExpectancyDisplayedColumns = ['test'];
      component.ShowHideColumns();
      expect(component.showHideColumn).toBeFalse();
      expect(component.normmalLossExpectancyDisplayedColumns.length).toBeLessThan(10);
    });
  });

  describe('Form Calculations', () => {
    it('should recalculate totals when dependencies change', () => {
      const row = component.createRow(mockNormalLossData[0]);
      (component as any).setupCalculationSubscribers(row);
      
      row.get('NormalLossPropertyDamage').setValue('3000');
      expect(row.get('TotalPDNLE').value).toContain('3500');
      
      row.get('NormalLossBusinessInterruption').setValue('4000');
      expect(row.get('TotalTE').value).toContain('5500');
    });
  });

  describe('Data Handling', () => {
    it('should process grouped data correctly', () => {
      const testData = [{
        Address: ['Address1', 'Address2'],
        City: ['City1', 'City2'],
        StateProvince: ['State1', 'State2']
      }];
      component.setRows(testData);
      expect(component.getFormArray().length).toBe(1);
    });
  });
});
