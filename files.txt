                                          GeneralPropertyComponent.ts
import { Component } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormControl, FormControlStatus, FormGroup, Validators } from '@angular/forms';
import { provideMomentDateAdapter } from '@angular/material-moment-adapter';
import { MatDatepickerInputEvent } from '@angular/material/datepicker';
import { MatDialog, MatDialogConfig } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { pairwise, startWith, Subscription } from 'rxjs';
import { CommonService } from '../../../../../shared/services/common.service';
import { MasterDataModel } from '../../../../dashboard/models/master-data';
import { ReToolConstants } from '../../../constants/re-tool.constants';
import { ActionEnum } from '../../../models/action-enum';
import { BusinessInterruptionRiskFactor } from '../../../models/business-interruption-risk-factor';
import { ConstructionRiskFactor } from '../../../models/construction-risk-factor';
import { FormDataSource } from '../../../models/form-data-source';
import { GeneralProperty } from '../../../models/general-property';
import { GeneralPropertyWeightResponse } from '../../../models/general-property-weight-response';
import { GridRowRecord } from '../../../models/grid-row-record';
import { HumanElementRiskFactor } from '../../../models/human-element-risk-factor';
import { LocationModel } from '../../../models/location';
import { PopupRequest } from '../../../models/popup-request';
import { PopupResponse } from '../../../models/popup-response';
import { PropertyMasterDataTypeEnum } from '../../../models/property-master-data-type-enum';
import { SubTabEncodedEnum } from '../../../models/re-tool-tabs-enum';
import { RedistributionWeight } from '../../../models/redistribution-weights';
import { RiskFactor } from '../../../models/risk-factor';
import { RiskFactorElementEnum } from '../../../models/risk-factor-element-enum';
import { BusinessInterruptionRiskCalculatorComponent } from '../../../popup/business-interruption-risk-calculator/business-interruption-risk-calculator.component';
import { CommentComponent } from '../../../popup/comment/comment.component';
import { ConstructionRiskFactorCalculatorPopupComponent } from '../../../popup/construction-risk-factor-calculator-popup/construction-risk-factor-calculator-popup.component';
import { HumanElementRiskFactorCalculatorComponent } from '../../../popup/human-element-risk-factor-calculator/human-element-risk-factor-calculator.component';
import { ReToolCalculationService } from '../../../service/re-tool-calculation-service';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { ReToolService } from '../../../service/re-tool.service';
import { Utility } from '../../../utility/mapper-util';

export const MY_FORMATS = {
  parse: {
    dateInput: 'DD-MMM-yyyy',
  },
  display: {
    dateInput: 'DD-MMM-yyyy',
    monthYearLabel: 'MMM YYYY',
    dateA11yLabel: 'LL',
    monthYearA11yLabel: 'MMMM YYYY',
  },
};

@Component({
  selector: 're-tool-general-property',
  templateUrl: './general-property.component.html',
  styleUrl: './general-property.component.css',
  providers: [
    provideMomentDateAdapter(MY_FORMATS)
  ],
})
export class GeneralPropertyComponent {
  generalPropertyForm: FormGroup;
  generalPropertyDataSource: MatTableDataSource<AbstractControl>;
  generalPropertyDisplayedColumns: string[] = [];
  generalPropertyData: GeneralProperty[] = [];
  subscription: Subscription | undefined = new Subscription();
  rowValuesMap: Map<number, any> = new Map();
  registeredAllSubscriptions: boolean = false;
  generalPropertyDropdownList: string[] = ReToolConstants.generalPropertyDropdownList;
  confidenceIndexList: string[] = ReToolConstants.confidenceIndexList;
  isConfidenceIndexSelect: boolean = false;
  inputValue: string = '';
  today = new Date();
  private previousFormStatus: FormControlStatus = ReToolConstants.valid;
  private humanElementRiskFactors: MasterDataModel[] = [];
  weights: GeneralPropertyWeightResponse[] | null = null;
  private businessInterruptionRiskFactors: MasterDataModel[] = [];
  private businessInterruptionMakeups: MasterDataModel[] = [];
  private businessInterruptionRiskDisasters: MasterDataModel[] = [];
  private redistributionWeights: RedistributionWeight[] = [];
  data: PopupRequest;
  isVisibleRiskFactorPopups: boolean = false;
  PropertyLocationId: number;
  notApplicable: string = ReToolConstants.NA;

  constructor(private reToolService: ReToolService, private fb: FormBuilder, private reToolTabService: ReToolTabService,
    private dialog: MatDialog, private calculationService: ReToolCalculationService, private commonService: CommonService) { }

  ngOnInit(): void {
    this.getHumanElementRisks();
    this.getBusinessInterruptionRisks();
    this.initializeForm();
    this.reToolTabService.emit('onFormComponentInit', { encodedTabIndex: SubTabEncodedEnum.GeneralProperty });
  }

  initializeForm() {
    const onInitializeGeneralPropertyData = this.reToolTabService.on('onInitializeGeneralPropertyData').subscribe({
      next: (event: FormDataSource) => {
        if (event.data) {
          this.getGeneralPropertyWeight(event?.data);
          this.generalPropertyDisplayedColumns = event?.columns;
          this.generalPropertyData = event?.data;
          this.generalPropertyData = this.reToolTabService
                    .mergePropertyValueData<GeneralProperty>(event?.data);
          this.generalPropertyForm = this.fb.group({
            rows: this.fb.array([])
          });
          this.initializeDataSource();
          this.generalPropertyDataSource = new MatTableDataSource(this.tableRowsControls);
        }
      },
      error: (error) => {
        throw new error
      }
    });
    this.subscription?.add(onInitializeGeneralPropertyData);

    this.subscription?.add(
      this.reToolTabService.on('onProcessingSave').subscribe((event) => {
        this.generalPropertyForm.markAllAsTouched();
        this.generalPropertyForm.markAsPristine();
        this.generalPropertyForm.updateValueAndValidity();
        this.setValidatorBasedOnConfidenceIndexSelected();
        this.reToolTabService.formStatus = this.generalPropertyForm.status;

        const hasFormError = this.generalPropertyForm.status === ReToolConstants.invalid;

        if (hasFormError) {
          this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
        } else {
          this.reToolTabService.emit('onSaveFormData', { formData: this.getGeneralPropertyFormData, subTabIndex: 2, tabInfo: event?.tabInfo, isTabChange: event?.isTabChange });
        }
      }));

    this.subscription?.add(
      this.generalPropertyForm?.statusChanges.subscribe((status) => {
        if (status !== this.previousFormStatus) {
          this.previousFormStatus = this.generalPropertyForm.status;
          this.reToolTabService.formStatus = this.generalPropertyForm.status;
        }
      })
    );
  }

  initializeDataSource() {
    const rows = this.getFormArray();
    rows.clear();
    this.generalPropertyData?.forEach((data, index) => {
      const row = this.createRow(data);
      rows.push(row);
      this.enablePDIndexAdjustedBy(row);
      this.getPropertyDamageIndexDisplayValue(row);
      this.setPreviousPropertyDamageIndexValue(row);
      this.reToolTabService.actionStateChange(row);
      this.calculateTotalPd(row);
    });
    this.disablePDIndexAdjustByBasedOnPDIndexValue();
  }

  createRow(data: GeneralProperty): FormGroup {
    return this.fb.group({
      ULId: new FormControl(data.ULId || ''),
      PropertyLocationId: new FormControl(data.PropertyLocationId || null),
      LocationName: new FormControl({ value: data.LocationName || '', disabled: true }),
      Country: new FormControl({ value: data.Country || ReToolConstants.blank, disabled: true }),
      Address: new FormControl({ value: data.Address || '', disabled: true }),
      City: new FormControl(data.City),
      StateProvince: new FormControl(data.City),
      StreetAddressToolTip: new FormControl(data.StreetAddressToolTip),
      NormalLossExpectancy: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.NormalLossExpectancy) || '0.0', disabled: true }),
      ProbableMaximumLoss: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.ProbableMaximumLoss) || '0.0', disabled: true }),
      MaximumForeseeableLoss: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.MaximumForeseeableLoss) || '0.0', disabled: true }),
      HumanElementCalculated: new FormControl(data.HumanElementCalculated),
      HumanElementUpdated: new FormControl(data.HumanElementUpdated),
      HumanElementUpdatedComment: new FormControl(data.HumanElementUpdatedComment),
      HumanElementDisplayValue: new FormControl(this.getHumanElementDisplayValue(data.HumanElementCalculated, data.HumanElementUpdated) || '0.0'),
      ConstructionCalculated: new FormControl(data.ConstructionCalculated),
      ConstructionDisplayValue: new FormControl(this.getConstructionDisplayValue(data.ConstructionCalculated, data.ConstructionUpdated) || '0.0'),
      ConstructionUpdated: new FormControl(data.ConstructionUpdated),
      ConstructionUpdatedComment: new FormControl(data.ConstructionUpdatedComment),
      ConstructionHazards: new FormControl(data.ConstructionHazards || '0'),
      DetectionSecurity: new FormControl(data.DetectionSecurity || '0'),
      AutomaticSprinklers: new FormControl(data.AutomaticSprinklers || '0'),
      FireWaterSupply: new FormControl(data.FireWaterSupply || '0'),
      FireManualResponse: new FormControl(data.FireManualResponse || '0'),
      SpecialHazards: new FormControl(data.SpecialHazards || '0'),
      EquipmentHazards: new FormControl(data.EquipmentHazards || '0'),
      ExternalExposures: new FormControl(data.ExternalExposures || '0'),
      BusinessInterruptionCalculated: new FormControl(data.BusinessInterruptionCalculated),
      BusinessInterruptionUpdated: new FormControl(data.BusinessInterruptionUpdated),
      BusinessInterruptionUpdatedComment: new FormControl(data.BusinessInterruptionUpdatedComment),
      BusinessInterruptionDisplayValue: new FormControl(this.getBusinessInterruptionDisplayValue(data.BusinessInterruptionCalculated, data.BusinessInterruptionUpdated) || '0.0'),
      PropertyDamageIndexCalculated: new FormControl({ value: data.PropertyDamageIndexCalculated || '0.0', disabled: true }),
      PropertyDamageIndexUpdated: new FormControl({ value: data.PropertyDamageIndexUpdated || '0.0', disabled: true }),
      PropertyDamageIndexAdjusted: new FormControl({ value: data.PropertyDamageIndexAdjusted || '', disabled: true }),
      PropertyDamageIndexUpdatedPrevious: new FormControl(data.PropertyDamageIndexUpdatedPrevious),
      BusinessInterruptionIndexCalculated: new FormControl({ value: data.BusinessInterruptionIndexCalculated || '0.0', disabled: true }),
      LocationQualityIndexCalculated: new FormControl({ value: data.LocationQualityIndexCalculated || '0.0', disabled: true }),
      ConfidenceIndex: new FormControl(data.ConfidenceIndex || '0'),
      LossPreventionSource: new FormControl({ value: data.LossPreventionSource || '', disabled: false }, []),
      LossPreventionDate: new FormControl({ value: this.setLossPreventionDate(data.LossPreventionDate) || null, disabled: false }, []),
      LossPreventionComments: new FormControl(data.LossPreventionComments || ''),
      Action: new FormControl(data.Action || ActionEnum.IsSaved),
      VerCol: data.VerCol,
      RiskFactor: new FormControl(data.RiskFactor),
      OccupancyGroupCode: new FormControl(data.OccupancyGroupCode || 0),
      OccupancyTypeCode: new FormControl(data.OccupancyTypeCode || 0),
      ConstructionHazardsComment: new FormControl(data.ConstructionHazardsComment || ''),
      DetectionSecurityComment: new FormControl(data.DetectionSecurityComment || ''),
      AutomaticSprinklersComment: new FormControl(data.AutomaticSprinklersComment || ''),
      FireWaterSupplyComment: new FormControl(data.FireWaterSupplyComment || ''),
      FireManualResponseComment: new FormControl(data.FireManualResponseComment || ''),
      SpecialHazardsComment: new FormControl(data.SpecialHazardsComment || ''),
      EquipmentHazardsComment: new FormControl(data.EquipmentHazardsComment || ''),
      ExternalExposuresComment: new FormControl(data.ExternalExposuresComment || ''),
      BuildingValue: new FormControl(Utility.formatNumber(data.BuildingValue) || '0.0'),
      EquipmentValue: new FormControl(Utility.formatNumber(data.EquipmentValue) || '0.0'),
      InventoryValue: new FormControl(Utility.formatNumber(data.InventoryValue) || '0.0'),
      OtherValue: new FormControl(Utility.formatNumber(data.OtherValue) || '0.0'),
      TotalPD: new FormControl(data.TotalPD || '0.0'),
      PayRollValue: new FormControl(data.PayRollValue || '0.0'),
      NormalLossDeficiencyDriven: new FormControl(data.NormalLossDeficiencyDriven || false),
      BusinessInterruptionValue: new FormControl(data.BusinessInterruptionValue || '0.0'),
      BusinessInterruptionOtherValue: new FormControl(data.BusinessInterruptionOtherValue || '0.0'),
      IndemnityPeriod: new FormControl(data.IndemnityPeriod || 0),
      PDIndexIndexUpdatedValidationControl: new FormControl(data.PropertyDamageIndexUpdated || '0.0', [Validators.max(10), Validators.min(0)]),
    });
  }

  get tableRowsControls() {
    return this.getFormArray().controls;
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return this.reToolService.generateFormElementIdAttribute(rowIndex, dataId, columnName);
  }

  onCellValueChange(event: Event, column: FormControl) {
    const cellElement = event.target as HTMLElement;
    const response: GridRowRecord = this.getGidRowRecordDetail(cellElement?.id);
    response.value = column.value;
    const row = this.getFormArray().at(response.rowIndex);
    row.patchValue({
      [response.columnName]: response.value,
      ['Action']: ActionEnum.IsModified
    });
  }

  openPopupOnCellClick(event: MouseEvent, element: any, column: string) {
    const cellElement = event.target as HTMLElement;
    const response: GridRowRecord = this.getGidRowRecordDetail(cellElement?.id);
    response.value = element.value;
    this.openDialog(response, element, column);
  }

  private openDialog(request: GridRowRecord, element?: any, popUpTitle?: string) {

    switch (request.columnName) {
      case ReToolConstants.humanElementDisplayValue:
        if (request.popup != null && request.popup != '') {

          const matDialogConfig = new MatDialogConfig();
          const humanElementRiskFactor: HumanElementRiskFactor
            = this.getDeserializeRiskFactor(request.value?.RiskFactor)?.humanElementRisk;

          const popupRequest: PopupRequest = {
            title: 'Property/Human Element Risk Factor Calculator',
            gridRecordDetail: request,
            data: {
              humanElementRiskFactors: this.humanElementRiskFactors,
              humanElementCalculated: request.value.HumanElementCalculated,
              humanElementUpdated: request.value.HumanElementUpdated,
              humanElementUpdatedComment: request.value.HumanElementUpdatedComment,
              humanElementRisk: humanElementRiskFactor,
            }
          };

          matDialogConfig.data = popupRequest;

          //request.popupTitle = AppConstants[request.columnName as keyof typeof AppConstants] as string;
          const dialogRef = this.dialog.open(HumanElementRiskFactorCalculatorComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe((result: PopupResponse) => {
            if (result.action === 1)
              this.updatePatchRowFromHEPopup(result);
          });
        }
        else {
          const matDialogConfig = new MatDialogConfig();
          matDialogConfig.data = request;
          const dialogRef = this.dialog.open(ConstructionRiskFactorCalculatorPopupComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe(result => {
            this.updatePatchRowFromHEPopup(result);
          });
        }
        break;
      case ReToolConstants.businessInterruptionDisplayValue:

        if (request.popup != null && request.popup != '') {

          const matDialogConfig = new MatDialogConfig();

          const businessInterruptionFactor: BusinessInterruptionRiskFactor
            = this.getBusinessInterruptionDeserializeRiskFactor(request.value?.RiskFactor)?.businessInterruptionRisk;
          const popupRequest: PopupRequest = {
            title: ReToolConstants.businessInterruptionRiskTitle,
            gridRecordDetail: request,
            data: {
              businessInterruptionRiskFactors: this.businessInterruptionRiskFactors,
              businessInterruptionMakeups: this.businessInterruptionMakeups,
              businessInterruptionRiskDisasters: this.businessInterruptionRiskDisasters,
              businessInterruptionCalculated: request.value.BusinessInterruptionCalculated,
              businessInterruptionUpdated: request.value.BusinessInterruptionUpdated,
              businessInterruptionUpdatedComment: request.value.BusinessInterruptionUpdatedComment,
              businessInterruptionRisk: businessInterruptionFactor,
            }
          };
          matDialogConfig.data = popupRequest;
          const dialogRef = this.dialog.open(BusinessInterruptionRiskCalculatorComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe((result: PopupResponse) => {
            if (result.action === 1)
              this.updatePatchRowFromBIPopup(result);
          });
        }
        else {
          const matDialogConfig = new MatDialogConfig();
          matDialogConfig.data = request;
          const dialogRef = this.dialog.open(ConstructionRiskFactorCalculatorPopupComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe(result => {
            this.updatePatchRowFromBIPopup(result);
          });
        }
        break;
      case ReToolConstants.ConstructionHazardsComment:
      case ReToolConstants.DetectionSecurityComment:
      case ReToolConstants.AutomaticSprinklersComment:
      case ReToolConstants.FireWaterSupplyComment:
      case ReToolConstants.FireManualResponseComment:
      case ReToolConstants.SpecialHazardsComment:
      case ReToolConstants.EquipmentHazardsComment:
      case ReToolConstants.ExternalExposuresComment:
        {
          this.PropertyLocationId = request.value.PropertyLocationId;
          let commentDetail = this.getSelectedRiskFactorCommentDetails(request);
          const dialogConfig = new MatDialogConfig();
          const locationName = element?.get('LocationName')?.value;
          const state = element?.get('StateProvince')?.value;
          const country = element?.get('Country')?.value;

          const popupRequest: PopupRequest = {
            title: '',
            gridRecordDetail: request,
            data: {
              Location: locationName,
              City: request.value.City,
              State: state,
              Country: country,
              Title: commentDetail?.caption,
              Description: commentDetail?.commentText,
              PropertyLocationId: this.PropertyLocationId,
            }
          };
          dialogConfig.data = popupRequest;
          const dialogRef = this.dialog.open(CommentComponent, dialogConfig);

          dialogRef.afterClosed().subscribe((result: PopupResponse) => {
            const row = this.getFormGroup(result?.gridRecordDetail?.rowIndex);
            var updatedCommentText = result?.data?.Description;
            //Execute after click on save button from comment popup
            if (result.action === 1) {
              this.updatePatchRowFromCommentPopup(row, result, updatedCommentText);
            }
          });
          break;
        }
      case ReToolConstants.constructionDisplayValue:

        if (request.popup != null && request.popup != '') {

          const matDialogConfig = new MatDialogConfig();

          const constructionFactor: ConstructionRiskFactor
            = this.getConstructionDeserializeRiskFactor(request.value?.RiskFactor)?.constructionRisk;
          const popupRequest: PopupRequest = {
            title: ReToolConstants.constructionRiskTitle,
            gridRecordDetail: request,
            data: {
              constructionCalculated: request.value.ConstructionCalculated,
              constructionUpdated: request.value.ConstructionUpdated,
              constructionUpdatedComment: request.value.ConstructionUpdatedComment,
              constructionRisk: constructionFactor,
            }
          };
          matDialogConfig.data = popupRequest;
          const dialogRef = this.dialog.open(ConstructionRiskFactorCalculatorPopupComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe((result: PopupResponse) => {
            if (result.action === 1)
              this.updatePatchRowFromConstructionPopup(result);
          });
        }
        else {
          const matDialogConfig = new MatDialogConfig();
          matDialogConfig.data = request;
          const dialogRef = this.dialog.open(ConstructionRiskFactorCalculatorPopupComponent, matDialogConfig);
          dialogRef.afterClosed().subscribe(result => {
            this.updatePatchRowFromConstructionPopup(result);
          });
        }
        break;
    }
  }

  updateDropDownSelection(index: number, dropDrownKey: string, value: number) {
    const row = this.getFormArray().at(index);
    if (row) {
      (row as any)[dropDrownKey] = value;
      row.patchValue({ Action: ActionEnum.IsModified });
    }

    this.calculatePdIndexValue(row, dropDrownKey, value);
  }

  updateConfidenceIndexSelection(index: number, dropDrownKey: string, data: number) {
    const row = this.getFormArray().at(index);
    if (row) {
      (row as any)[dropDrownKey] = data;
      row.patchValue({ Action: ActionEnum.IsModified });
    }
  }

  handleBlur(event: any, index: number) {
    const input = (event.target as HTMLInputElement).value;
    const decimalValue = parseFloat(input);

    if (input === '' || isNaN(decimalValue)) {
      event.target.value = this.inputValue;
    } else if (decimalValue < -2.0 || decimalValue > 2.0) {
      event.target.value = '';
    }
    else if (!isNaN(decimalValue)) {
      event.target.value = parseFloat(input).toFixed(1);
    }
    const row = this.getFormGroup(index);
    let totalPDIndex = '0.0';
    const propertyDamageIndexCalculated = parseFloat(row.get('PropertyDamageIndexCalculated')?.value);
    const propertyDamageIndexAdjusted = parseFloat(row.get('PropertyDamageIndexAdjusted')?.value);
    const propertyDamageIndexUpdated = parseFloat(row.get('PropertyDamageIndexUpdated')?.value);

    if (propertyDamageIndexUpdated === 0) {
      totalPDIndex = ((propertyDamageIndexCalculated + propertyDamageIndexAdjusted)).toFixed(1);
      row.get('PropertyDamageIndexUpdatedPrevious').setValue(propertyDamageIndexCalculated.toFixed(1));
    }
    else if (propertyDamageIndexAdjusted != 0 && !isNaN(propertyDamageIndexAdjusted)) {
      totalPDIndex = ((propertyDamageIndexCalculated + propertyDamageIndexAdjusted)).toFixed(1);
      row.get('PropertyDamageIndexUpdatedPrevious').setValue(propertyDamageIndexCalculated.toFixed(1));
    }
    else if (propertyDamageIndexAdjusted === 0 && !isNaN(propertyDamageIndexAdjusted)) {
      totalPDIndex = ((propertyDamageIndexCalculated + propertyDamageIndexAdjusted)).toFixed(1);
      row.get('PropertyDamageIndexUpdatedPrevious').setValue(propertyDamageIndexCalculated.toFixed(1));
    }

    if (isNaN(decimalValue)) {
      row.get('PropertyDamageIndexUpdated').setValue(propertyDamageIndexCalculated.toFixed(1));
    }
    else {
      row.get('PropertyDamageIndexUpdated').setValue(totalPDIndex);
    }

    this.setValidatorForPdIndexValue(row, Number(totalPDIndex));
  }

  isValidRating(rating: string): boolean {
    return rating !== ReToolConstants.NA && rating !== null;
  }

  //Get the selected data in popup on page load
  getSelectedRiskFactorCommentDetails(response: GridRowRecord): { commentText?: string, caption: string } {
    const row = this.getFormGroup(response?.rowIndex);
    let comment = row.get(response.columnName).value;
    let caption;
    switch (response.columnName) {
      case ReToolConstants.ConstructionHazardsComment:
        caption = ReToolConstants.ConstructionHazardsCommentCaption;
        break;
      case ReToolConstants.DetectionSecurityComment:
        caption = ReToolConstants.DetectionSecurityCommentCaption;
        break;
      case ReToolConstants.AutomaticSprinklersComment:
        caption = ReToolConstants.AutomaticSprinklersCommentCaption;
        break;
      case ReToolConstants.FireWaterSupplyComment:
        caption = ReToolConstants.FireWaterSupplyCommentCaption;
        break;
      case ReToolConstants.FireManualResponseComment:
        caption = ReToolConstants.FireManualResponseCommentCaption;
        break;
      case ReToolConstants.SpecialHazardsComment:
        caption = ReToolConstants.SpecialHazardsCommentCaption;
        break;
      case ReToolConstants.EquipmentHazardsComment:
        caption = ReToolConstants.EquipmentHazardsCommentCaption;
        break;
      case ReToolConstants.ExternalExposuresComment:
        caption = ReToolConstants.ExternalExposuresCommentCaption;
        break;
    }
    return { commentText: comment, caption: caption };
  }

  //Save the changes data in comment popup
  updatePatchRowFromCommentPopup(row: any, result: PopupResponse, description: string) {
    var columnName = result?.gridRecordDetail?.columnName;
    switch (columnName) {
      case ReToolConstants.ConstructionHazardsComment:
        row.controls.ConstructionHazardsComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.DetectionSecurityComment:
        row.controls.DetectionSecurityComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.AutomaticSprinklersComment:
        row.controls.AutomaticSprinklersComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.FireWaterSupplyComment:
        row.controls.FireWaterSupplyComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.FireManualResponseComment:
        row.controls.FireManualResponseComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.SpecialHazardsComment:
        row.controls.SpecialHazardsComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.EquipmentHazardsComment:
        row.controls.EquipmentHazardsComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
      case ReToolConstants.ExternalExposuresComment:
        row.controls.ExternalExposuresComment.value = description;
        row.controls.Action.value = ActionEnum.IsModified;
        break;
    }
  }

  onSubmit() {
    this.generalPropertyForm.markAllAsTouched();
    this.reToolTabService.formStatus = this.generalPropertyForm.status;
    this.setValidatorBasedOnConfidenceIndexSelected();

    if (this.generalPropertyForm.status == ReToolConstants.valid) {
      this.reToolTabService.emit('onSaveFormData', { formData: this.getGeneralPropertyFormData, subTabIndex: 2});
    } else {
      this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
    }
  }

  private setValidatorBasedOnConfidenceIndexSelected(): void {
    const rows = this.getFormArray();
    rows.controls?.forEach((control) => {
      const lossPreventionSource = control?.get('LossPreventionSource');
      const lossPreventionDate = control?.get('LossPreventionDate');
      const confidenceIndexValue = control?.get('ConfidenceIndex')?.value;
      let lossPreventionDateValue = control?.get('LossPreventionDate')?.value;

      if (confidenceIndexValue > 0) {
        lossPreventionSource?.setValidators([Validators.required]);
        lossPreventionDate?.setValidators([Validators.required]);
        this.isConfidenceIndexSelect = true
      } else {
        this.isConfidenceIndexSelect = false;
        lossPreventionSource?.setValidators([]);
        lossPreventionDate?.setValidators([]);

        if (lossPreventionDateValue != null) {
          lossPreventionDateValue = this.commonService.getDateByTimeZone(new Date(lossPreventionDateValue), new Date(lossPreventionDateValue).getTimezoneOffset())
          control?.get('LossPreventionDate')?.setValue(lossPreventionDateValue);
        }
      }
      lossPreventionSource?.updateValueAndValidity();
      lossPreventionDate?.updateValueAndValidity();
    });
  }

  private getGidRowRecordDetail(input: string): GridRowRecord {
    const [rowPart, idPart, column, popup] = input.split('_');
    const record: GridRowRecord = {
      rowIndex: parseInt(rowPart.split('-')[1]),
      columnName: column,
      rowPKId: parseInt(idPart.split('-')[1]),
      value: '',
      popup: popup
    };
    return record;
  }

  private get getGeneralPropertyFormData(): GeneralProperty[] {
    return this.getFormArray()?.getRawValue() as GeneralProperty[];
  }

  private getFormArray(): FormArray {
    return (this.generalPropertyForm.get('rows') as FormArray);
  }

  private getFormGroup(rowIndex: number): FormGroup {
    return (this.getFormArray()
      .at(rowIndex) as FormGroup);
  }

  private updatePatchRowFromHEPopup(response: PopupResponse) {
    const row = this.getFormGroup(response?.gridRecordDetail?.rowIndex);
    const data = response.data;

    let riskFactor = row.get('RiskFactor')?.value;

    if (!riskFactor && !Utility.isRiskFactor(JSON.parse(riskFactor)))
      riskFactor = Utility.getRiskFactorDefaultValue();
    else
      riskFactor = JSON.parse(riskFactor);

    riskFactor.humanElementRisk = data.humanElementRisk;

    const humanElementDisplayValue = this.getHumanElementDisplayValue(data.humanElementCalculated, data.humanElementUpdated);
    row.patchValue({
      ['HumanElementDisplayValue']: humanElementDisplayValue,
      ['HumanElementCalculated']: response.data.humanElementCalculated,
      ['HumanElementUpdated']: response.data.humanElementUpdated,
      ['HumanElementUpdatedComment']: response.data.humanElementUpdatedComment,
      ['RiskFactor']: this.getSerializeRiskFactorFactors(riskFactor),
      ['Action']: ActionEnum.IsModified
    });

    this.calculatePdIndexValue(row, ReToolConstants.humanElementColumnField, Number(humanElementDisplayValue));
  }

  private updatePatchRowFromBIPopup(response: PopupResponse) {
    const row = this.getFormGroup(response?.gridRecordDetail?.rowIndex);
    const data = response.data;

    let riskFactor = row.get('RiskFactor')?.value;

    if (!riskFactor && !Utility.isBusinessInterruptionRiskFactor(JSON.parse(riskFactor)))
      riskFactor = Utility.getBusinessInterruptionRiskFactorDefaultValue();
    else
      riskFactor = JSON.parse(riskFactor);

    riskFactor.businessInterruptionRisk = data.businessInterruptionRisk;
    
    row.patchValue({
      ['BusinessInterruptionDisplayValue']: this.getBusinessInterruptionDisplayValue(data.businessInterruptionCalculated, data.businessInterruptionUpdated),
      ['BusinessInterruptionCalculated']: response.data.businessInterruptionCalculated,
      ['BusinessInterruptionUpdated']: response.data.businessInterruptionUpdated,
      ['BusinessInterruptionUpdatedComment']: response.data.businessInterruptionUpdatedComment,
      ['RiskFactor']: this.getBusinessInterruptionSerializeRiskFactors(riskFactor),
      ['Action']: ActionEnum.IsModified
    });
  }

  private getHumanElementRisks(): void {
    const getHumanElementRisks = this.reToolService.getPropertyMaster(PropertyMasterDataTypeEnum.HumanElementRiskFactor).subscribe({
      next: (response) => {
        this.humanElementRiskFactors = response.humanElementRiskFactors;
      },
      error: (error) => {
        throw new error;
      }
    });
    this.subscription?.add(getHumanElementRisks);
  }

  private getBusinessInterruptionRisks(): void {
    const getBusinessInterruptionRisks = this.reToolService.getPropertyMaster(PropertyMasterDataTypeEnum.BIRiskFactor).subscribe({
      next: (response) => {
        this.businessInterruptionRiskFactors = response.businessInterruptionRiskFactors;
        this.businessInterruptionMakeups = response.businessInterruptionMakeups;
        this.businessInterruptionRiskDisasters = response.businessInterruptionRiskDisasters;
      },
      error: (error) => {
        throw new error;
      }
    });
    this.subscription?.add(getBusinessInterruptionRisks);
  }

  private getHumanElementDisplayValue(humanElementCalculated: any, humanElementUpdated: any) {
    if (humanElementUpdated != null && !isNaN(humanElementUpdated) && Number(humanElementUpdated) > 0) {
      return parseFloat(humanElementUpdated.toString()).toFixed(1);
    }
    else if (humanElementUpdated === ReToolConstants.NA) return ReToolConstants.NA;
    else if (humanElementCalculated != null && !isNaN(humanElementCalculated))
      return parseFloat(humanElementCalculated.toString()).toFixed(1);
    else
      return '0.0';
  }

  private getBusinessInterruptionDisplayValue(businessInterruptionCalculated: any, businessInterruptionUpdated: any) {

    if (businessInterruptionUpdated != null && !isNaN(businessInterruptionUpdated) && Number(businessInterruptionUpdated) > 0) {
      return parseFloat(businessInterruptionUpdated.toString()).toFixed(1);
    }
    else if (businessInterruptionUpdated === ReToolConstants.NA) return ReToolConstants.NA;
    else if (businessInterruptionCalculated != null && !isNaN(businessInterruptionCalculated))
      return parseFloat(businessInterruptionCalculated.toString()).toFixed(1);
    else
      return '0.0';
  }

  private getDeserializeRiskFactor(value: string): RiskFactor {
    if (value) {
      const parseValue = JSON.parse(value) as RiskFactor;
      if (parseValue && parseValue.humanElementRisk)
        return parseValue;
      else
        return Utility.getRiskFactorDefaultValue();
    }

    return Utility.getRiskFactorDefaultValue();
  }

  private getSerializeRiskFactorFactors(riskFactors: any): any {
    if (Utility.isRiskFactor(riskFactors)) {
      return JSON.stringify(riskFactors);
    }

    return null;
  }

  private getBusinessInterruptionDeserializeRiskFactor(value: string): RiskFactor {
    if (value) {
      const parseValue = JSON.parse(value) as RiskFactor;
      if (parseValue && parseValue.businessInterruptionRisk)
        return parseValue;
      else
        return Utility.getBusinessInterruptionRiskFactorDefaultValue();
    }
    return Utility.getBusinessInterruptionRiskFactorDefaultValue();
  }

  private getBusinessInterruptionSerializeRiskFactors(riskFactors: any): any {
    if (Utility.isBusinessInterruptionRiskFactor(riskFactors)) {
      return JSON.stringify(riskFactors);
    }
    return null;
  }

  prevantFutureDate(event: MatDatepickerInputEvent<Date>, rowIndex: number) {
    const manualEnteredDate = this.commonService.getDateByTimeZone(new Date(event.value), new Date(event.value).getTimezoneOffset());
    
    if (manualEnteredDate > new Date()) {
      this.reToolTabService.showErrorMessage(ReToolConstants.futureDatePrevantionMessage, '');
    }
    const row = this.getFormArray().at(rowIndex);
    row.patchValue({
      ['Action']: ActionEnum.IsModified
    });
  }

  private getWeightDistributionCode(row: AbstractControl<any, any>) {
    if (row.value) {
      const occupancyTypeCode = Number(row.get('OccupancyTypeCode')?.value);
      if (Utility.isValidOccupancyTypeCode(occupancyTypeCode)) {
        return occupancyTypeCode;
      }
      else
        return Number(row.get('OccupancyGroupCode')?.value);
    }
    else {
      return null;
    }

  }

  private buildRedistributedWeightData(gpData: GeneralProperty[]): void {
    if (this.weights && this.weights.length > 0) {
      this.weights.forEach((data: GeneralPropertyWeightResponse, index) => {
        const gpRow = gpData.find((gp) => (!!gp.OccupancyGroupCode && gp.OccupancyGroupCode === data.occupancyGroupId || gp.OccupancyTypeCode === data.typeCode))
        const generalPropertyWeights: RedistributionWeight = {
          groupCode: data.groupCode,
          occupancyGroupId: data.occupancyGroupId,
          groupTypeCode: data.typeCode,
          inputWeights: {
            humanElement: data.humanElement.toString(),
            construction: data.construction.toString(),
            constructionHazards: data.constructionHazards.toString(),
            detectionSecurity: data.detectionSecurity.toString(),
            automaticSprinklers: data.automaticSprinklers.toString(),
            fireWaterSupply: data.fireWaterSupply.toString(),
            fireManualResponse: data.fireManualResponse.toString(),
            specialHazards: data.specialHazards.toString(),
            equipmentHazards: data.equipmentHazards.toString(),
            externalExposures: data.externalExposures.toString()
          },
          inputRatings: {
            humanElement: parseFloat(this.getHumanElementDisplayValue(gpRow.HumanElementCalculated, gpRow.HumanElementUpdated).toString()) || 0,
            construction: parseFloat(this.getConstructionDisplayValue(gpRow.ConstructionCalculated, gpRow.ConstructionUpdated).toString()) || 0,
            constructionHazards: gpRow.ConstructionHazards?.toString() || 0,
            detectionSecurity: gpRow.DetectionSecurity?.toString() || 0,
            automaticSprinklers: gpRow.AutomaticSprinklers?.toString() || 0,
            fireWaterSupply: gpRow.FireWaterSupply?.toString() || 0,
            fireManualResponse: gpRow.FireManualResponse?.toString() || 0,
            specialHazards: gpRow.SpecialHazards?.toString() || 0,
            equipmentHazards: gpRow.EquipmentHazards?.toString() || 0,
            externalExposures: gpRow.ExternalExposures?.toString() || 0
          },
          redistributedWeights: {} as any
        };
        this.redistributionWeights.push(generalPropertyWeights);
      });
    }
  }

  private getGeneralPropertyWeight(gpData: GeneralProperty[]): void {
    let occupancyCodes = gpData.map(data => {
      if (Utility.isValidOccupancyTypeCode(data.OccupancyTypeCode)) {
        return data.OccupancyTypeCode;
      }
      else
        return data.OccupancyGroupCode;
    });

    const generalPropertyWeights = this.reToolService.getGeneralPropertyWeight(occupancyCodes).subscribe({
      next: (response: GeneralPropertyWeightResponse[] | null) => {
        if (response !== null && response.length > 0) {
          // store the entire object into weights
          this.weights = response;
          this.buildRedistributedWeightData(gpData);
          this.calculationService
            .setRedistributionWeights(this.redistributionWeights)
            .calculate();
        }
      },
      error: (error) => { }
    });
    this.subscription?.add(generalPropertyWeights);
  }

  private enablePDIndexAdjustedBy(row: FormGroup<any>) {
    const reportedPropertyTotalPDValue = row.get('PropertyDamageIndexCalculated')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null && res != '0.0') {
          this.setPropertyDamageIndexDisplayValue(row);
          row.controls['PropertyDamageIndexAdjusted'].enable();
        }
        else {
          row.controls['PropertyDamageIndexAdjusted'].setValue('');
          row.controls['PropertyDamageIndexCalculated'].setValue('0.0');
          this.setPropertyDamageIndexDisplayValue(row);
          row.controls['PropertyDamageIndexAdjusted'].disable();
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(reportedPropertyTotalPDValue);
  }

  private getPropertyDamageIndexDisplayValue(row: FormGroup<any>) {
    const propertyDamageIndexCalculatedValue = row.get('PropertyDamageIndexCalculated').value;
    const propertyDamageIndexAdjustedValue = row.get('PropertyDamageIndexAdjusted').value;

    if (propertyDamageIndexAdjustedValue === '') {
      row.get('PropertyDamageIndexUpdated').setValue(propertyDamageIndexCalculatedValue);
    }
  }

  private setPreviousPropertyDamageIndexValue(row: FormGroup<any>) {

    row.get('PropertyDamageIndexUpdated')?.valueChanges
      .pipe(startWith(null), pairwise())
      .subscribe(([prev, next]: [any, any]) => {

        if (JSON.parse(prev) != null)
          row.get('PropertyDamageIndexUpdatedPrevious').setValue(prev);
      });
  }

  private disablePDIndexAdjustByBasedOnPDIndexValue(): void {
    const rows = this.getFormArray();
    rows.controls?.forEach((control) => {
      const propertyDamageIndexAdjusted = control?.get('PropertyDamageIndexAdjusted');

      const propertyDamageIndexCalculated = parseFloat(control?.get('PropertyDamageIndexCalculated')?.value);
      if (propertyDamageIndexCalculated === 0) {
        propertyDamageIndexAdjusted?.disable();
      } else {
        propertyDamageIndexAdjusted?.enable();
      }
    });
  }

  private setPropertyDamageIndexDisplayValue(row: FormGroup<any>) {
    let totalPDIndex = '0.0';
    const propertyDamageIndexCalculated = parseFloat(row.get('PropertyDamageIndexCalculated')?.value);
    const propertyDamageIndexAdjusted = parseFloat(row.get('PropertyDamageIndexAdjusted')?.value);
    const propertyDamageIndexUpdated = parseFloat(row.get('PropertyDamageIndexUpdated')?.value);
    const pdIndexUpdatedControl = row.get('PropertyDamageIndexUpdated');

    if (propertyDamageIndexUpdated != 0 && !isNaN(propertyDamageIndexAdjusted)) {
      totalPDIndex = ((propertyDamageIndexCalculated + propertyDamageIndexAdjusted)).toFixed(1);
      pdIndexUpdatedControl?.setValue(totalPDIndex);
      this.setValidatorForPdIndexValue(row, Number(totalPDIndex));
    } else {
      row.get('PropertyDamageIndexUpdated').setValue(propertyDamageIndexCalculated.toFixed(1));
      this.setValidatorForPdIndexValue(row, Number(totalPDIndex));
    }
  }

  private getConstructionDeserializeRiskFactor(value: string): RiskFactor {
    if (value) {
      const parseValue = JSON.parse(value) as RiskFactor;
      if (parseValue && parseValue.constructionRisk)
        return parseValue;
      else
        return Utility.getConstructionRiskFactorDefaultValue();
    }
    return Utility.getConstructionRiskFactorDefaultValue();
  }

  private updatePatchRowFromConstructionPopup(response: PopupResponse) {
    const row = this.getFormGroup(response?.gridRecordDetail?.rowIndex);
    const data = response.data;

    let riskFactor = row.get('RiskFactor')?.value;

    if (!riskFactor && !Utility.isConstructionRiskFactor(JSON.parse(riskFactor)))
      riskFactor = Utility.getConstructionRiskFactorDefaultValue();
    else
      riskFactor = JSON.parse(riskFactor);

    riskFactor.constructionRisk = data.constructionRisk;

    const constructionDisplayValue = this.getConstructionDisplayValue(data.constructionCalculated, data.constructionUpdated);
    row.patchValue({
      ['ConstructionDisplayValue']: constructionDisplayValue,
      ['ConstructionCalculated']: response.data.constructionCalculated,
      ['ConstructionUpdated']: response.data.constructionUpdated,
      ['ConstructionUpdatedComment']: response.data.constructionUpdatedComment,
      ['RiskFactor']: this.getConstructionSerializeRiskFactors(riskFactor),
      ['Action']: ActionEnum.IsModified
    });

    this.calculatePdIndexValue(row, ReToolConstants.constructionColumnField, Number(constructionDisplayValue));
  }

  private getConstructionSerializeRiskFactors(riskFactors: any): any {
    if (Utility.isConstructionRiskFactor(riskFactors)) {
      return JSON.stringify(riskFactors);
    }
    return null;
  }

  private getConstructionDisplayValue(constructionCalculated: any, constructionUpdated: any) {

    if (constructionUpdated != null && !isNaN(constructionUpdated) && Number(constructionUpdated) > 0) {
      return parseFloat(constructionUpdated.toString()).toFixed(1);
    }
    else if (constructionUpdated === ReToolConstants.NA) return ReToolConstants.NA;
    else if (constructionCalculated != null && constructionCalculated != "" && !isNaN(constructionCalculated))
      return parseFloat(constructionCalculated.toString()).toFixed(1);
    else
      return '0.0';
  }

  private calculatePdIndexValue(row: AbstractControl<any,any>, elementKey: string, value: number){
    const riskFactorElementEnumValue = RiskFactorElementEnum[elementKey as keyof typeof RiskFactorElementEnum];
    const groupCode = this.getWeightDistributionCode(row);

    if (groupCode) {
      const pdIndexValue = this.calculationService
        .setPropertyData<GeneralProperty>(row.getRawValue() as GeneralProperty)
        .setGroupOrTypeCode(groupCode)
        .setElement(riskFactorElementEnumValue)
        .updateWeightDistribution(value)
        .getPDIndexValue();

      if (pdIndexValue !== -1) {
        row.get('PropertyDamageIndexCalculated').setValue(pdIndexValue.toFixed(1));
      }
    }
  }

  private calculateTotalPd(row: FormGroup<any>) {
    const buildingValue = parseFloat(Utility.removeComma(row.get('BuildingValue')?.value)) || 0.0;
    const equipmentValue = parseFloat(Utility.removeComma(row.get('EquipmentValue')?.value)) || 0.0;
    const inventoryValue = parseFloat(Utility.removeComma(row.get('InventoryValue')?.value)) || 0.0;
    const otherValue = parseFloat(Utility.removeComma(row.get('OtherValue')?.value)) || 0.0;
    const totalPD = buildingValue + equipmentValue + inventoryValue + otherValue;
    row.get('TotalPD').setValue(totalPD, { emitEvent: false });
  }

  private setValidatorForPdIndexValue(row: FormGroup<any>, totalPdIndex: number): void
  {
    const pdIndexIndexUpdatedValidationControl = row.get('PDIndexIndexUpdatedValidationControl');
    const propertyDamageIndexUpdatedControl = row.get('PropertyDamageIndexUpdatedPrevious');
    if (Number(totalPdIndex) > 10)
    {
      pdIndexIndexUpdatedValidationControl?.setErrors({max: true});
      this.reToolTabService.showErrorMessage(ReToolConstants.pdIndexUpdateValueRangeValidation,"");
    }
    else if(Number(totalPdIndex) < 0)
    {
      pdIndexIndexUpdatedValidationControl?.setErrors({min: true});
      this.reToolTabService.showErrorMessage(ReToolConstants.pdIndexNegativeUpdateValueRangeValidation,""); 
    }
    else
    {
      pdIndexIndexUpdatedValidationControl?.setErrors(null);
    }

    propertyDamageIndexUpdatedControl?.updateValueAndValidity();
  }

  private setLossPreventionDate(lossPreventionDate: any) {

    if (lossPreventionDate != null) {
      return this.commonService.getDateByTimeZone(new Date(lossPreventionDate), new Date(lossPreventionDate).getTimezoneOffset());
    }
    
    else
      return null;
  }

  ngOnDestroy() {
    if (this.subscription) {
      this.subscription?.unsubscribe();
    }
  }
}
--------------------GeneralProperty----------------

import { ActionEnum } from "./action-enum"
import { BaseTabModel } from "./base-tab-model";
import { LocationModel } from "./location";

export class GeneralProperty implements BaseTabModel {
    ULId: string = '';
    PropertyLocationId?: number = 0;
    Address: string = '';
    City: string = '';
    Country: string = '';
    LocationName: string = '';
    StateProvince: string = '';
    NormalLossExpectancy?: number = 0;
    ProbableMaximumLoss?: number = 0;
    MaximumForeseeableLoss?: number = 0;
    HumanElementCalculated?: number = null;
    HumanElementUpdated?: number = null;
    HumanElementUpdatedComment?: string = null;
    HumanElementDisplayValue?: number = 0.0;
    ConstructionCalculated?:number = null;
    ConstructionUpdated?: number = null;
    ConstructionUpdatedComment?: string = null;
    ConstructionDisplayValue?: number = 0.0;
    ConstructionHazards: string = '';
    DetectionSecurity: string = '';
    AutomaticSprinklers?: number = null;
    FireWaterSupply: string = '';
    FireManualResponse: string = '';
    SpecialHazards: string = '';
    EquipmentHazards: string = '';
    ExternalExposures: string = '';
    BusinessInterruptionCalculated?: number = 0.0;
    BusinessInterruptionUpdated?: number = 0.0;
    BusinessInterruptionUpdatedComment?: string = null;
    BusinessInterruptionDisplayValue?: number = 0.0;
    PropertyDamageIndexCalculated?: number = 0.0;
    PropertyDamageIndexUpdated?: number = 0.0;
    PropertyDamageIndexAdjusted?: number = 0.0;
    PropertyDamageIndexUpdatedPrevious?: number = 0.0;
    BusinessInterruptionIndexCalculated?: number = 0.0;
    LocationQualityIndexCalculated?: number = 0.0;
    ConfidenceIndex: string = '';
    LossPreventionSource: string = '';
    LossPreventionDate?: Date;
    LossPreventionComments: string = '';
    RiskFactor?: any = null;
    Action: ActionEnum = ActionEnum.IsNewRecord;
    VerCol: string;
    OccupancyGroupCode: number = 0;
    OccupancyTypeCode: number = 0;
    RedistributedWeights?: number[] = [] ;
    ConstructionHazardsComment?: string = '';
    DetectionSecurityComment?:string = "";
    AutomaticSprinklersComment?:string ="";
    FireWaterSupplyComment?:string = "";
    FireManualResponseComment?:string = "";
    SpecialHazardsComment?:string = "";
    EquipmentHazardsComment?:string = "";
    ExternalExposuresComment?:string = "";
    BuildingValue: number = 0.0;
    EquipmentValue: number = 0.0;
    InventoryValue: number = 0.0;
    OtherValue: number = 0.0;
    TotalPD?: number = 0.0;
    BusinessInterruptionValue: number = 0.0;
    BusinessInterruptionOtherValue: number = 0.0;
    PayRollValue: number = 0.0;
    NormalLossDeficiencyDriven: boolean = false;
    IndemnityPeriod: number = 0.0;
    StreetAddressToolTip?: any = [];
}
--------------GeneralPropertyWeightResponse------------

export interface GeneralPropertyWeightResponse {
    generalPropertyGroupCodeWeightId: number;
    occupancyGroupId: number;
    groupCode: number;
    typeCode: number;
    humanElement: number;
    construction: number;
    constructionHazards: number;
    detectionSecurity: number;
    automaticSprinklers: number;
    fireWaterSupply: number;
    fireManualResponse: number;
    specialHazards: number;
    equipmentHazards: number;
    externalExposures: number;
    totalPropertyDamage: number;
    totalBusinessInterruption: number;
    statusId: number;
}

---------MasterDataModel-------
export class MasterDataModel {
  text: string;
  value: string;
  category: string;
  defaultValue: string;
  dependentValue: any;
  disabled: boolean = false;
  fullText:string;
}

export interface RedistributionWeight {
    groupCode: number;
    occupancyGroupId: number;
    groupTypeCode: number;
    inputWeights: RedistributionWeightElement;
    inputRatings: RedistributionWeightElement;
    redistributedWeights:RedistributionWeightElement
}

export interface RedistributionWeightElement{
    humanElement?: string | number;
    construction?: string | number;
    constructionHazards?: string | number;
    detectionSecurity?: string | number;
    automaticSprinklers?: string | number;
    fireWaterSupply?: string | number;
    fireManualResponse?: string | number;
    specialHazards?: string | number;
    equipmentHazards?: string | number;
    externalExposures?: string | number;
}

import { GridRowRecord } from "./grid-row-record";
export interface PopupRequest {
    title: string;
    data:any;
    gridRecordDetail:GridRowRecord;
}
import { Injectable } from '@angular/core';
import { PropertyValue } from '../models/property-value';
import { catchError, Observable, Subject, tap, throwError } from 'rxjs';
import { ReToolConstants } from '../constants/re-tool.constants';
import { environment } from '../../../../environments/environment';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { NormalLossExpectancy } from '../models/normal-loss-expectancy';
import { ProbableMaximumLoss } from '../models/probable-maximum-loss';
import { MaximumForeseeableLoss } from '../models/maximum-foreseeable-loss';
import { EquipmentProbableMaximumLoss } from '../models/equipment-probable-maximum-loss';
import { PropertyMasterDataTypeEnum } from '../models/property-master-data-type-enum';
import { GeneralPropertyWeightResponse } from '../models/general-property-weight-response';
import { Cover } from '../models/cover';
import { PropertyLocationImportRequest } from '../models/property-location-import-request';
import { LocationFilterModel } from '../../loc-address/models/location-name-address';

const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type': 'application/json'
  })
};

@Injectable({
  providedIn: 'root'
})

export class ReToolService {
  public addNewLocationSubject = new Subject<void>();
  addNewLocation$ = this.addNewLocationSubject.asObservable();
  public currencyUnitSubject = new Subject<any>();
  currencyUnit$ = this.currencyUnitSubject.asObservable();
  public locationApiDataSubscribe$ = new Subject<any>();
  public countrySearchSubject$ = new Subject<any>();
  public humanElementRiskFactorSubject = new Subject<any>();
  humanElementRiskFactor$ = this.humanElementRiskFactorSubject.asObservable();
  private importDataSubject = new Subject<{ locationData: any, propertyValueData: any }>();
  importData$ = this.importDataSubject.asObservable();

  private readonly httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    })
  };

  constructor(private http: HttpClient) { }

  getLocationProperties(reviewRequestId: number, isGeneralProperty: boolean): Observable<PropertyValue[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetAllProperty/${reviewRequestId}/${isGeneralProperty}`);
  }

  getCoverWithPropertyValues(reviewRequestId: number): Observable<Cover> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyAccountCover/${reviewRequestId}`);
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return `row-${rowIndex}_dataKey-${dataId}_${columnName}_${popUp}`;
  }

  getLocationByAddress(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetAddressSearch/${query}`, httpOptions);
  }

  getLocationByGeoCode(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetGeoCode/${query}`, httpOptions);
  }

  getPropertyMaster(type: PropertyMasterDataTypeEnum): Observable<any> {
    let params = new HttpParams();
    if (type == PropertyMasterDataTypeEnum.HumanElementRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.BIRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.Cover) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    const options = {
      ...this.httpOptions,
      params
    }

    if (type === PropertyMasterDataTypeEnum.CurrencyAndUnit) {
      return this.http.get<any>(`${environment.baseUrl}Property`, options)
        .pipe(
          tap(data => this.currencyUnitSubject.next(data)),
          catchError(error => {
            return throwError(() => new Error(error.message));
          })
        );
    }
    else
      return this.http.get<any>(`${environment.baseUrl}Property`, options);
  };

  getEnumPropertyName = (value: number): string => {
    return PropertyMasterDataTypeEnum[value];
  };

  getOccupancyGroup(productLine: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetRequestCompleteMaster/?productLine=${productLine}`, httpOptions);
  }

  getOccupancyType(occupancyGroupId: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetOccupancyType/?occupancyGroupId=${occupancyGroupId}`, httpOptions);
  }

  // Generic POST request for submitting the data to the api
  // could update once backend API ready
  post<T>(url: string, body: any): Observable<T> {
    return this.http.post<any>(url, body, this.httpOptions).pipe(catchError(this.handleError));
  }

  //Generic GET request for api calling
  // could update once backend API ready
  get<T>(url: string): Observable<T> {
    return this.http.get<T>(url, this.httpOptions).pipe(
      tap((response) => response),
      catchError(this.handleError)
    );
  }

  handleError(error: any): Observable<never> {
    throw new Error(error.message);
  }

  getPropertyFireLocations(reviewRequestId: number): Observable<NormalLossExpectancy[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${reviewRequestId}`);
  }

  getProbableMaximumLoss(reviewRequestId: number): Observable<ProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getMaximumForeseeableLoss(reviewRequestId: number): Observable<MaximumForeseeableLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getPropertyEquipmentBreakdownLocations(reviewRequestId: number): Observable<EquipmentProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${reviewRequestId}`);
  }

  getGeneralPropertyWeight(occupancyCodes: any): Observable<GeneralPropertyWeightResponse[]> {
    return this.post<GeneralPropertyWeightResponse[]>(`${environment.baseUrl}Master/GetGeneralPropertyWeight`, occupancyCodes);
  }

  importData(data: any, propertyValueData: any) {
    this.importDataSubject.next({ locationData: data, propertyValueData: propertyValueData });
  }

  importPropertyLocations(data: PropertyLocationImportRequest[]): any {
    const apiURL = `${environment.baseUrl}Property/PropertyLocationImport`;
    return this.http.post(apiURL, data);
  }

  searchLocationByName(locationFilter: LocationFilterModel) {
    const body = JSON.stringify(locationFilter);
    return this.http.post<any>(`${environment.baseUrl}Property/GetLocationSuggestionByName`, body, httpOptions);
  }
  
  searchCountryName(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Property/GetCountrySuggestionByName/${query}`, httpOptions);
  }
}
import { Injectable } from '@angular/core';
import { FormControlStatus, FormGroup } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, catchError, filter, map, Observable, of, Subject, Subscription, switchMap } from 'rxjs';
import { environment } from '../../../../environments/environment';
import { AppConstants } from '../../../shared/constants/app.constants';
import { ReToolConstants } from '../constants/re-tool.constants';
import { ActionEnum } from '../models/action-enum';
import { Cover } from '../models/cover';
import { PropertyEquipmentLocation } from '../models/property-equipment-location';
import { PropertyFireLocation } from '../models/property-fire-location';
import { PropertyLocation } from '../models/property-location';
import { PropertyValue } from '../models/property-value';
import { SavePropertyLocationRequestModel } from '../models/savePropertyRequest';
import { ReToolService } from './re-tool.service';

interface DynamicAccessiblePropertyItem {
  ULId?: string;
  Address: string;
  City?: string;
  StateProvince: string;
  LocationAddressMapId?: number;
}

@Injectable({
  providedIn: 'root'
})
export class ReToolTabService {
  reviewRequestId: number;
  private dataSourceSubject$ = new Subject<{ event: string, payload: any }>();
  public hasFormChange$ = new BehaviorSubject<boolean>(false);
  public selectedCurrencyUnitSubject$ = new BehaviorSubject<any>(null);
  private selectedLocAddressData = new BehaviorSubject<any>(null);
  selectedLocAddressData$ = this.selectedLocAddressData.asObservable();
  formStatus: FormControlStatus = ReToolConstants.valid;
  subscription: Subscription | undefined = new Subscription();
  propertyLocationForm: FormGroup;
  tabIndex: number;
  subTabIndex: number;
  productLineId: number = 0;
  currencyUnitValid: boolean = true;
  allPropertyValuesDeleted: boolean = false;
  private locAddressPopupClosedSubject: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  locAddressPopupClosedSubject$ = this.locAddressPopupClosedSubject.asObservable();

  propertyLocationColumns: string[] = [
    "ULID",
    "LocationName",
    "StreetAddress",
    "CityName",
    "StateName",
    "CountryName",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "BusinessInterruptionValue",
    "BusinessInterruptionOtherValue",
    "IndemnityPeriod",
    "PayRollValue",
    "PayRollDayValue",
    "TotalTE",
    "Total",
    "Delete"
  ];

  occupancyColumns: string[] = [
    "ULID",
    "LocationName",
    "StreetAddress",
    "CountryName",
    "OccupancyGroup",
    "OccupancyType",
    "OccupancyCode",
    "Hazard",
    "EquipmentBreakdown",
    "GroupBuildingArea",
    "AutomaticSprinklersPercentage",
    "AutomaticSprinklersNeededPercentage"
  ];

  generalPropertyColumns: string[] = [
    "ULID",
    "LocationName",
    "StreetAddress",
    "CountryName",
    "NormalLossExpectancy",
    "ProbableMaximumLoss",
    "MaximumForeseeableLoss",
    "HumanElementCalculated",
    "ConstructionCalculated",
    "ConstructionHazards",
    "DetectionSecurity",
    "AutomaticSprinklers",
    "FireWaterSupply",
    "FireManualResponse",
    "SpecialHazards",
    "EquipmentHazards",
    "ExternalExposures",
    "BusinessInterruptionCalculated",
    "PropertyDamageIndexUpdated",
    "PropertyDamageIndexAdjusted",
    "BusinessInterruptionIndexCalculated",
    "LocationQualityIndexCalculated",
    "ConfidenceIndex",
    "LossPreventionSource",
    "LossPreventionDate",
    "LossPreventionComments"
  ];

  normalLossExpectancyColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "NormalLossCompare",
    "NormalLossScenario",
    "NormalLossDeficiencyDriven",
    "NormalLossPropertyDamage",
    "NormalLossOtherPropertyDamage",
    "TotalPDNLE",
    "NormalLossBusinessInterruption",
    "NormalLossInterBusinessInterruption",
    "NormalLossOtherTimeElement",
    "TotalTE",
    "NLEActual",
    "NormalLossIndemnityPeriodBI",
    "IPFactTotal",

  ];

  probableMaximumLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "PML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  maximumForeseeableLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "MFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  equipmentProbableMaximumLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "EBPML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  equipmentMaximumForeseeableLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "EBMFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  coverColumns: string[] = [
    "ReportedBuildingValue",
    "ReportedContentsValue",
    "ReportedTotalPD",
    "ReportedTotalBivalue",
    "ReportedTIV",
    "ReviewedBuilding",
    "ReviewedContents",
    "ReviewedTotalPD",
    "ReviewedTotalBI",
    "ReviewedTIV",
    "ReviewedPercentageBuilding",
    "ReviewedPercentageContents",
    "ReviewedPercentageTotalPD",
    "ReviewedPercentageTotalBI",
    "ReviewedPercentageTIV",
    "TimeElementExcluded",
    "RecommendedReviewFrequency",
    "RecommendedAccountPercentageTIV",
    "OccupancyGroupTIV",
    "OccupancyTypeTIV",
    "OccupancyCodeTIV",
    "HazardTIV",
    "EquipmentBreakdownTIV",
    "DeviationTIV",
    "IsHazardTIVUpdated",
    "IsEquipmentBreakdownUpdatedTIV",
    "OccupancyGroupHighestHazardReview",
    "OccupancyTypeHighestHazardReview",
    "OccupancyCodeHighestHazardReview",
    "OccupancyHighestHazardReview",
    "EquipmentBreakdownHazardReview",
    "DeviationHighestHazardReview",
    "IsHighestHazardReviewUpdated",
    "IsEBRHighestHazardReviewUpdated",
    "IsHazardUpdated",
    "IsEquipmentBreakdownUpdated",
    "Interdependency",
    "ContingentTimeElement",
    "QualityOfSupplyChainInfo",
    "SCRiskMgmt",
    "SupplyChainConfidence"
  ];

  constructor(private reToolService: ReToolService, private toastr: ToastrService) { }

  emit(event: string, ds: any) {
    this.dataSourceSubject$.next({ event: event, payload: ds });
  }

  on(event: string): Observable<any> {
    return this.dataSourceSubject$.asObservable().pipe(
      filter(e => e.event === event),
      map(e => e.payload)
    );
  }

  setUpPropertyValuesData(isGeneralProperty: boolean = false): Observable<any> {
    return this.reToolService.getLocationProperties(this.reviewRequestId, isGeneralProperty);
  }

  setUpCoverWithPropertyValuesData(): Observable<any> {
    return this.reToolService.getCoverWithPropertyValues(this.reviewRequestId);
  }

  setUpPropertyValueWithDefaultData(): Observable<any> {
    return of([new PropertyValue(), new PropertyValue()]);
  }

  setUpPropertyFireLocationData(): Observable<any> {
    return this.reToolService.getPropertyFireLocations(this.reviewRequestId);
  }

  setUpProbableMaximumLossData(): Observable<any> {
    return this.reToolService.getProbableMaximumLoss(this.reviewRequestId);
  }

  setUpMaximumForeseeableLossData(): Observable<any> {
    return this.reToolService.getMaximumForeseeableLoss(this.reviewRequestId);
  }

  setUpPropertyEquipmentLocationData(): Observable<any> {
    return this.reToolService.getPropertyEquipmentBreakdownLocations(this.reviewRequestId);
  }

  // The purpose of this logic is to maintain a parent and sub tab association
  // which can be used individually as a single value to determine tab relationships
  encodeTabIndex(parentTabIndex: number, subTabIndex: number): number {
    if (parentTabIndex === 0) return 1;
    return ((parentTabIndex << 3) | subTabIndex);
  }

  // This is to fetch parent and sub tab indexes out of association value
  // it could be removed if not needed in future
  decodeTabIndex(encodedTabIndexValue: number): { parentTabIndex: number, subtabIndex: number } {
    const parentIndex = (encodedTabIndexValue >> 3) & 7;//shift right by 3 bits and mask with 7 (0111)
    const subIndex = encodedTabIndexValue & 7;
    return { parentTabIndex: parentIndex, subtabIndex: subIndex } as any;
  }

  saveUpdateDeleteAndFetchThePropertyValueFormData(data: SavePropertyLocationRequestModel, isTabChange: boolean = false): Observable<any> {
    const isGeneralProperty = false;
    const postUrl = `${environment.baseUrl}Property`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  updatePropertyLocationFormData(data: PropertyLocation[], isTabChange: boolean = false, isGeneralProperty: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/UpdateOccupancyOrGeneralProperty`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchThePropertyFireLocationFormData(data: PropertyFireLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/AddOrUpdatePropertyFireLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  private saveUpdateAndFetchTheLatestActiveFormData<T>(postUrl: string, data: any, getUrl: string): Observable<T> {
    return this.reToolService.post(postUrl, data).pipe(
      switchMap((postResponse) => {
        if (getUrl) {
          return this.reToolService.get<T>(getUrl);
        } else {
          return of(postResponse as T);
        }
      }),
      catchError(this.reToolService.handleError)
    )
  }

  showErrorMessage(message: string, action: string) {
    this.toastr.error(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  showSuccessMessage(message: string, action: string) {
    this.toastr.success(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  actionStateChange(formGroup: FormGroup) {
    this.subscription?.add(
      formGroup?.get('Action').valueChanges.subscribe(value => {
        this.hasFormChange$.next((value != ActionEnum.IsSaved))
      })
    );
  }

  saveUpdateAndFetchThePropertyEquipmentLocationFormData(data: PropertyEquipmentLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/UpdatePropertyEquipmentBreakdownLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchTheCoverFormData(data: Cover, isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/SaveOrUpdatePropertyAccountCover`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyAccountCover/${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  mergePropertyValueData<T extends DynamicAccessiblePropertyItem>(data: T[]): T[] {
    const mergeMap = new Map<string, Partial<T & {
      StreetAddresses: string[],
      CityNames: string[],
      StateProvinces: string[],
      LocationAddressMapIds: number[]
    }>>();

    let mergedData: any[] = [];
    data.forEach(item => {
      const key = item.ULId;

      if (!mergeMap.has(key)) {
        mergeMap.set(key, {
          ...item,
          StreetAddresses: [],
          CityNames: [],
          StateProvinces: [],
          LocationAddressMapIds: []
        });
      }

      const existing = mergeMap.get(key);
      existing.StreetAddresses.push(item.Address);
      existing.CityNames.push(item.City);
      existing.StateProvinces.push(item.StateProvince);
      if (item instanceof PropertyValue)
        existing.LocationAddressMapIds.push(item.LocationAddressMapId);
    });

    mergedData = Array.from(mergeMap.values());
    mergedData.forEach(x => this.setAddressAndToolTip(x));
    return mergedData;
  }

  // handle tooltip and final grid values
  setAddressAndToolTip(data: any) {
    if (Array.from(new Set(data.StreetAddresses)).length > 1
      || Array.from(new Set(data.CityNames)).length > 1
      || Array.from(new Set(data.StateProvinces)).length > 1) {
      data.Address = ReToolConstants.multiple;
    } else {
      data.Address = data.StreetAddresses[0];
    }

    if (Array.from(new Set(data.CityNames)).length > 1) {
      data.City = ReToolConstants.multiple;
    } else {
      data.City = data.CityNames[0];
    }

    if (Array.from(new Set(data.StateProvinces)).length > 1) {
      data.StateProvince = ReToolConstants.multiple;
    } else {
      data.StateProvince = data.StateProvinces[0];
    }

    const streetAddressToolTip = [];
    streetAddressToolTip.push(data.StreetAddresses.map((address, index) => {
      const city = data.CityNames[index] ? `${data.CityNames[index]}, ` : '';
      return `${address}, ${city} ${data.StateProvinces[index]}`
    }));

    data.StreetAddressToolTip = [...new Set(streetAddressToolTip[0])].join('\n');
  }

  SetLocAddressSelectedData(data: any[]) {
    this.selectedLocAddressData.next(data);
  }
  
  setLocAddressPopupClosedSubject(status: boolean): void {
    this.locAddressPopupClosedSubject.next(status);
  }
}

------------------------------

import { Injectable } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { RoleNameEnum } from '../enums/rolename.enum';
import { UserDetailsModel } from '../../core/models/user-details-model';
import { MatSnackBar } from '@angular/material/snack-bar'
import { AppConstants } from '../constants/app.constants';
import { ProductLineEnum } from '../enums/productline.enum';
import { FormGroup } from '@angular/forms';
import { RequestStatusCount } from '../../features/dashboard/models/request-status-count';
import { UserFeatureEnum } from '../enums/userfeature.enum';
import { DatePipe } from '@angular/common';
import { AppMaintenanceModel } from '../../core/models/app-maintenance';
@Injectable({
  providedIn: 'root'
})
export class CommonService {
  private subjectToggleView = new Subject<boolean>();
  subjectToggleView$ = this.subjectToggleView.asObservable();
  userDetails: UserDetailsModel | undefined;
  private subjectRequestStatusCountSub = new Subject<RequestStatusCount>();
  subjectRequestStatusCountSub$ = this.subjectRequestStatusCountSub.asObservable();
  private subjectAccountClearedSource = new Subject<void>();
  subjectAccountClearedSub$ = this.subjectAccountClearedSource.asObservable();
  private loadSavedFiltersSource = new Subject<void>();
  loadSavedFiltersSub$ = this.loadSavedFiltersSource.asObservable();
  appMaintainenanceDetails: AppMaintenanceModel | undefined;
  private appMaintainenaceSub = new BehaviorSubject<boolean>(false);
  appMaintainenaceSub$ = this.appMaintainenaceSub.asObservable();
  private headerVisible = new Subject<boolean>();
  headerVisible$ = this.headerVisible.asObservable();

  constructor(private snackBar: MatSnackBar, private datePipe: DatePipe) { }

  loadSavedFilters() {
    this.loadSavedFiltersSource.next();
  }

  snackbarSuccessMessage(message: string, Title: string = "", _horizontalPosition: any = AppConstants.snackbarHorizontalPosition, _verticalPosition: any = AppConstants.snackbarVerticalPosition) {
    this.snackBar.open(message, Title, {
      duration: AppConstants.snackbarDuration,
      horizontalPosition: _horizontalPosition,
      verticalPosition: _verticalPosition,
      panelClass: [AppConstants.snackbarSuccessStyle],
    });
  }

  snackbarErrorMessage(message: string, Title: string = "", _horizontalPosition: any = AppConstants.snackbarHorizontalPosition, _verticalPosition: any = AppConstants.snackbarVerticalPosition) {
    this.snackBar.open(message, Title, {
      duration: AppConstants.snackbarDuration,
      horizontalPosition: _horizontalPosition,
      verticalPosition: _verticalPosition,
      panelClass: [AppConstants.snackbarErrorStyle],
    });
  }

  getDateByTimeZone(date, minutes) {
    if (minutes < 0) {
      date.setMinutes(date.getMinutes() + (minutes * -1));
    }
    else if (minutes > 0) {
      date.setMinutes(date.getMinutes() - (minutes * +1));
    }
    return date;
  }

  isUserFromUnderwriterGroup() {
    return this.userDetails?.roleId == RoleNameEnum.Underwriter || this.userDetails?.roleId == RoleNameEnum.UnderwriterTechnician || this.userDetails?.roleId == RoleNameEnum.UnderwriterManager;
  }

  isUserFromRiskEngineerGroup() {
    return this.userDetails?.roleId == RoleNameEnum.RiskEngineer || this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader || this.userDetails?.roleId == RoleNameEnum.GlobalLeader;
  }

  isUserFromValuationGroup() {
    return this.userDetails?.roleId == RoleNameEnum.ValuationLeader || this.userDetails?.roleId == RoleNameEnum.ValuationSpecialist;
  }

  isUserFromRiskEngineerGroupByToggleView(iSToggleShow: boolean) {
    return iSToggleShow ? this.userDetails?.roleId == RoleNameEnum.RiskEngineer || this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader : this.userDetails?.roleId == RoleNameEnum.RiskEngineer || this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader || this.userDetails?.roleId == RoleNameEnum.GlobalLeader;
  }

  isUserFromRiskEngineerGroupExceptGlobalLeader() {
    return this.userDetails?.roleId == RoleNameEnum.RiskEngineer || this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader;
  }

  isRoleFromRiskEngineerGroupExceptGlobalLeader(roleId) {
    return roleId == RoleNameEnum.RiskEngineer || roleId == RoleNameEnum.CountryLeader || roleId == RoleNameEnum.RegionalLeader;
  }

  isRoleFromValuationGroup(roleId) {
    return roleId == RoleNameEnum.ValuationLeader || roleId == RoleNameEnum.ValuationSpecialist;
  }

  isRoleFromUnderwriterGroup(roleId) {
    return roleId == RoleNameEnum.Underwriter || roleId == RoleNameEnum.UnderwriterTechnician || roleId == RoleNameEnum.UnderwriterManager;
  }

  isUserFromLeaderRole() {
    return this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader || this.userDetails?.roleId == RoleNameEnum.ValuationLeader;
  }

  isUserFromUWGroupOrRiskEngineer() {
    return this.userDetails?.roleId == RoleNameEnum.Underwriter || this.userDetails?.roleId == RoleNameEnum.UnderwriterTechnician || this.userDetails?.roleId == RoleNameEnum.UnderwriterManager || this.userDetails?.roleId == RoleNameEnum.RiskEngineer;
  }

  isUserAssociatedwithBuiderRiskOrMarine() {
    return (this.userDetails?.productLineId == ProductLineEnum.BuildersRisk || this.userDetails?.productLineId == ProductLineEnum.Marine)
  }

  addValidators(formGroup: FormGroup, validator: any) {
    for (const key in formGroup.controls) {
      formGroup.get(key).setValidators(validator[key]);
      formGroup.get(key).updateValueAndValidity();
    }
  }

  removeValidators(formGroup: FormGroup,) {
    formGroup.clearValidators();
    formGroup.updateValueAndValidity();
  }

  checkNullValue(value: any): any {
    return value == "" || value == undefined || value == null ? null : value
  }

  isValueEmpty(value: any): any {
    return value == "" || value == undefined || value == null || value.length <= 0 || value == 'null'
  }

  isValueEmptyAndNotLessThanZero(value: any): any {
    return value === "" || value === undefined || value === null || value === 'null'
  }

  checkNullOrBlank(value: any): any {
    return value == null || value == '' || value == undefined ? '-' : value
  }

  checkNullOrZero(value: any): any {
    return value == "" || value == "0" || value == undefined || value == null ? null : value
  }

  sendRequestStatusCount(requestStatusCount: RequestStatusCount) {
    this.subjectRequestStatusCountSub.next(requestStatusCount);
  }

  getPermissionStatus(featureId: number): boolean {
    const userPermission = this.userDetails?.userPermission
      .find(
        permission => permission.userFeatureId == featureId
      );

    return userPermission != null && userPermission != undefined;
  }

  triggerAccountCleared() {
    this.subjectAccountClearedSource.next();
  }

  snackbarErrorMessageforAlert(message: string, Title: string = "", _horizontalPosition: any = AppConstants.snackbarHorizontalPosition, _verticalPosition: any = AppConstants.snackbarVerticalPosition) {
    this.snackBar.open(message, Title, {
      duration: AppConstants.snackbarDurationforAlert,
      horizontalPosition: _horizontalPosition,
      verticalPosition: _verticalPosition,
      panelClass: [AppConstants.snackbarErrorStyleForAlert],
    });
  }

  removeYearSubFolder(filepath: string): string {
    //split the filepath by '\\'
    const parts = filepath.split('\\');

    //find index of year part
    const yearIndex = parts.findIndex(part => /^\d{4}$/.test(part));

    //keep the parts upto and including the year
    const newParts = yearIndex !== -1 ? parts.slice(0, yearIndex) : parts;

    const newFilepath = newParts.join('/');
    return newFilepath;
  }

  isUserFromRiskEngineerGroupExceptRiskEngineer() {
    return this.userDetails?.roleId == RoleNameEnum.CountryLeader || this.userDetails?.roleId == RoleNameEnum.RegionalLeader || this.userDetails?.roleId == RoleNameEnum.GlobalLeader;
  }

  isUserAdmin() {
    const admin = this.userDetails?.userPermission.find(permission =>
      permission.userFeatureId == UserFeatureEnum.userAdmin
    );
    return admin != null && admin != undefined;
  }

  getDropdownSelectValue(value: any): any {
    return (value == "" || value == undefined || value == null || value == 0) ? AppConstants.defaultDropDownValue : value.toString()
  }

  convertToMediumDateFromat(value: Date): any {
    return (value == null || value == undefined) ? '-' : this.datePipe.transform(value, 'mediumDate')
  }

  setAppMaintainenance(status: boolean) {
    this.appMaintainenaceSub.next(status);
  }

  showHeader() {
    this.headerVisible.next(true);
  }

  hideHeader() {
    this.headerVisible.next(false);
  }

  getProductLineParameterForEdW(productLineId) {
    switch (productLineId.toString()) {

      case ProductLineEnum.GeneralCorporateProperty.toString():
      case ProductLineEnum.Mining.toString():
      case ProductLineEnum.PowerGeneration.toString():
      case ProductLineEnum.OilGasAndPetrochemical.toString():
      case ProductLineEnum.BuildersRisk.toString():
      case ProductLineEnum.MidMarketMittelstandProperty.toString():
        return AppConstants.productLineProperty;

      case ProductLineEnum.Marine.toString():
        return AppConstants.productLineMarine;

      case ProductLineEnum.Programs.toString():
        return AppConstants.productLinePrograms;

      case ProductLineEnum.Other.toString():
      default:
        return null;
    }
  }

  formatToDate(date: string | Date): any {
    if (!date) return '-';
    const parsedDate = new Date(date);
    return isNaN(parsedDate.getTime()) ? '-' : parsedDate.setHours(0,0,0,0);
  }
  
  convertExcelDate(cell: any): void {
    if (cell && typeof cell.v === 'number') {
      const excelDate = new Date(cell.v); //Directly used JS Date object, we are getting in milliseconds no need of further conversion
      excelDate.setHours(0, 0, 0, 0);
      
      // check if excel date is invalid
      if(isNaN(excelDate.getTime())){
        return;
      }

      let serialDate = (excelDate.getTime() - new Date(1900, 0, 1).getTime()) / (1000 * 60 * 60 * 24) + 3;
      serialDate = Math.floor(serialDate);
      cell.v = serialDate;
      cell.t = 'n';
      cell.z = 'DD-MMM-YYYY';
    }
  }
}


