\\------------------------------CoverCompleteReviewEmailComponent.ts--------------------------------

import { Component, inject, Inject, signal } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { debounceTime, Subscription } from 'rxjs';
import { PopupResponse } from '../../models/popup-response';
import { ReToolConstants } from '../../constants/re-tool.constants';
import { GridRowRecord } from '../../models/grid-row-record';
import { MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { PopupRequest } from '../../models/popup-request';
import { ReToolTabService } from '../../service/re-tool-tab.service';
import { CompleteReviewEmail } from '../../models/complete-review-email';
import { LiveAnnouncer } from '@angular/cdk/a11y';
import { COMMA, ENTER } from '@angular/cdk/keycodes';
import { MatChipInputEvent } from '@angular/material/chips';
import { ReToolService } from '../../service/re-tool.service';
import { MatAutocompleteSelectedEvent } from '@angular/material/autocomplete';

@Component({
    selector: 'app-cover-complete-review-email',
    templateUrl: './cover-complete-review-email.component.html',
    styleUrl: './cover-complete-review-email.component.css',
})
export class CoverCompleteReviewEmailComponent {
    subscription: Subscription | undefined = new Subscription();
    title: string = '';
    coverCompleteReviewEmailForm!: FormGroup;
    completeReviewEmailModel: CompleteReviewEmail = null;
    resultResponse: PopupResponse = { action: 0, data: null, gridRecordDetail: {} as GridRowRecord };
    reToolConstant = ReToolConstants;
    textAreaHeightReset: boolean = true;
    currentMailReceiver = signal('');
    addOnBlur = true;
    readonly separatorKeysCodes = [ENTER, COMMA] as const;
    ccReceiver = signal([]);
    toReceiver = signal([]);
    allMailReceiver: string[] = [];
    filteredEmails: any;
    readonly announcer = inject(LiveAnnouncer);

    constructor(private fb: FormBuilder, public dialogRef: MatDialogRef<CoverCompleteReviewEmailComponent>,
        @Inject(MAT_DIALOG_DATA) public request: PopupRequest, private reToolTabService: ReToolTabService, private reToolService: ReToolService) { }

    ngOnInit() {
        this.title = this.request?.title;
        this.initializeForm();
        this.ccReceiver.set(this.request?.data?.ccMailIds);
        this.toReceiver.set([this.request?.data?.underWritter]);

        this.coverCompleteReviewEmailForm.get('CCEmailValue').valueChanges
            .pipe(debounceTime(300))
            .subscribe(value => {
                this.currentMailReceiver.set(value);
                this.getActiveEmail(value);
            });

        this.coverCompleteReviewEmailForm.get('ToEmailValue').valueChanges
            .pipe(debounceTime(300))
            .subscribe(value => {
                this.currentMailReceiver.set(value);
                this.getActiveEmail(value);
            });
    }

    initializeForm() {
        this.coverCompleteReviewEmailForm = this.fb.group({
            UnderWritter: new FormControl({ value: this.request?.data?.underWritter, disabled: false }),
            CCUserMailIds: new FormControl({ value: this.request?.data?.ccUserMailIds, disabled: false }),
            CCMailIds: new FormControl(this.request?.data?.ccMailIds),
            PropertyAccountId: new FormControl(this.request?.data?.propertyAccountId),
            ReviewRequestId: new FormControl(this.request?.data?.reviewRequestId),
            AccountName: new FormControl(this.request?.data?.accountName),
            Subject: new FormControl({ value: this.request?.data?.subject, disabled: false }),
            Message: new FormControl({ value: this.request?.data?.message, disabled: false }),
            CCEmailValue: new FormControl({ value: '', disabled: false }),
            ToEmailValue: new FormControl({ value: '', disabled: false }),
        });
    }

    onClose(result: any): void {
        this.resultResponse.action = 0;
        this.dialogRef.close(this.resultResponse);
    }

    onSave(result: any) {
        this.coverCompleteReviewEmailForm.markAllAsTouched();
        this.coverCompleteReviewEmailForm.markAsPristine();

        if (this.coverCompleteReviewEmailForm.status === ReToolConstants.valid) {
            const formData = this.getcoverCompleteReviewEmailFormData();
            this.request.data.UnderWritter = formData.UnderWritter;
            this.request.data.ccUserMailIds = formData.CCUserMailIds;
            this.request.data.ccMailIds = formData.CCMailIds;
            this.request.data.subject = formData.Subject;
            this.request.data.message = formData.Message;
            this.resultResponse.data = this.request.data;
            this.resultResponse.action = 1;
            const requestModel: any = {
                PropertyAccountId: formData.PropertyAccountId,
                ReviewRequestId: formData.ReviewRequestId,
                ToEmailIds: this.toReceiver().join(';'),
                CCEmailIds: this.ccReceiver().join(';'),
                Subject: formData.Subject,
                Message: formData.Message,
                AccountName: formData.AccountName
            }

            const objSendMailRequest = this.reToolService.sendCoverCompleteMailRequest(requestModel).subscribe({
                next: (response) => {
                    if (response === true) {
                        this.reToolTabService.showSuccessMessage(ReToolConstants.coverCompleteReviewEmailSuccess, '');
                        this.dialogRef.close(this.resultResponse);
                    } else {
                        this.reToolTabService.showErrorMessage(ReToolConstants.coverCompleteReviewEmailFail, '');
                    }
                },
                error: (error) => {
                },
            });
            this.subscription?.add(objSendMailRequest);
        }
        else
            this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
    }

    adjustHeight(event: Event): void {
        const textarea = event.target as HTMLTextAreaElement;
        textarea.style.height = 'auto';
        textarea.style.height = `${textarea.scrollHeight}px`;
    }

    private getcoverCompleteReviewEmailFormData(): any {
        return this.coverCompleteReviewEmailForm.getRawValue();
    }

    addCCEmail(event: MatChipInputEvent): void {
        const value = (event.value || '').trim();
        // Add cc
        if (value && value.endsWith(ReToolConstants.validEmailDomain)) {
            this.ccReceiver.update(emails => [...emails, value]);
        }

        // Clear the input value
        this.currentMailReceiver.set('');
        this.coverCompleteReviewEmailForm.get('CCEmailValue').value('');
        event.chipInput!.clear();
    }

    addToEmail(event: MatChipInputEvent): void {
        const value = (event.value || '').trim();
        // Add to
        if (value && value.endsWith(ReToolConstants.validEmailDomain)) {
            this.toReceiver.update(emails => [...emails, value]);
        }

        // Clear the input value
        this.currentMailReceiver.set('');
        this.coverCompleteReviewEmailForm.get('ToEmailValue').value('');
        event.chipInput!.clear();
    }

    removeCcEmail(email: string): void {
        this.ccReceiver.update(emails => {
            const index = emails.indexOf(email);
            if (index < 0) {
                return emails;
            }

            emails.splice(index, 1);
            this.announcer.announce(`Removed ${email}`);
            return [...emails];
        });
    }

    removeToEmail(email: string): void {
        this.toReceiver.update(emails => {
            const index = emails.indexOf(email);
            if (index < 0) {
                return emails;
            }

            emails.splice(index, 1);
            this.announcer.announce(`Removed ${email}`);
            return [...emails];
        });
    }

    selectedCCEmail(event: MatAutocompleteSelectedEvent): void {
        this.ccReceiver.update(emails => [...emails, event.option.value]);
        this.currentMailReceiver.set('');
        event.option.deselect();
    }

    selectedToEmail(event: MatAutocompleteSelectedEvent): void {
        this.toReceiver.update(emails => [...emails, event.option.value]);
        this.currentMailReceiver.set('');
        event.option.deselect();
    }

    getActiveEmail(input: any): void {
        if (this.currentMailReceiver() != '' && input != '' && input.length >= 3) {
            const completeReviewMailIds = this.reToolService.getActiveUserNameAndEmail(this.currentMailReceiver()).subscribe({
                next: (response) => {
                    if (response !== null && response !== undefined && response.length > 0) {
                        this.allMailReceiver = response.map(res => ({ mailId: res.email, userName: res.userName }));
                        this.filteredEmails = this.allMailReceiver;
                    }
                },
                error: (error) => {
                    throw new Error(error);
                }
            });
            this.subscription.add(completeReviewMailIds);
        }
    }
}
\\------------------------------cover-complete-review-email.component.html

<div class="modal-dialog modal-md modal-dialog-centered">
<div class="modal-content">
    <form [formGroup]="coverCompleteReviewEmailForm">
        <div class="modal-header">
            <h1 class="modal-title">{{title}}</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"
                (click)="onClose(true)"></button>
        </div>
        <div class="modal-body scrollbar p-1 pb-3">
            <div class="container-fluid">
                <div class="row g-2">
                    <div class="col-12 email-box">
                        <label>To</label>
                        <mat-label></mat-label>
                        <mat-chip-grid #chipGrid aria-label="Email selection">
                            @for (toEmail of toReceiver(); track $index) {
                            <mat-chip-row (removed)="removeToEmail(toEmail)">
                                {{toEmail}}
                                <button matChipRemove [attr.aria-label]="'remove ' + toEmail">
                                    <mat-icon>cancel</mat-icon>
                                </button>
                            </mat-chip-row>
                            }
                        </mat-chip-grid>
                        <input class="chip-input-visible form-control" placeholder="New Email..." #toEmailInput
                            formControlName="ToEmailValue"
                            [matChipInputFor]="chipGrid"
                            [matAutocomplete]="auto" 
                            [matChipInputSeparatorKeyCodes]="separatorKeysCodes"
                            (matChipInputTokenEnd)="addToEmail($event)" />
                        <mat-autocomplete #auto="matAutocomplete"
                            (optionSelected)="selectedToEmail($event); toEmailInput.value = ''">
                            @for (toMail of filteredEmails; track toMail) {
                            <mat-option [value]="toMail.mailId"><span class="option-fw-nm">{{toMail.userName}}</span><br><span class="option-fw-em">{{toMail.mailId}}</span> </mat-option>
                            }
                        </mat-autocomplete>
                    </div>
                    <div class="col-12 email-box">
                        <label>CC</label>
                        <div class="col-12">
                                <mat-label></mat-label>
                                <mat-chip-grid #chipGrid aria-label="Email selection">
                                    @for (ccEmail of ccReceiver(); track $index) {
                                    <mat-chip-row (removed)="removeCcEmail(ccEmail)">
                                        {{ccEmail}}
                                        <button matChipRemove [attr.aria-label]="'remove ' + ccEmail">
                                            <mat-icon>cancel</mat-icon>
                                        </button>
                                    </mat-chip-row>
                                    }
                                </mat-chip-grid>
                                <input class="chip-input-visible form-control" placeholder="New Email..." #ccEmailInput
                                    formControlName="CCEmailValue"
                                    [matChipInputFor]="chipGrid"
                                    [matAutocomplete]="auto1" 
                                    [matChipInputSeparatorKeyCodes]="separatorKeysCodes"
                                    (matChipInputTokenEnd)="addCCEmail($event)" />
                                <mat-autocomplete #auto1="matAutocomplete"
                                    (optionSelected)="selectedCCEmail($event); ccEmailInput.value = ''">
                                    @for (ccMail of filteredEmails; track ccMail) {
                                    <mat-option [value]="ccMail.mailId"><span class="option-fw-nm">{{ccMail.userName}}</span><br><span class="option-fw-em">{{ccMail.mailId}}</span> </mat-option>
                                    }
                                </mat-autocomplete>
                        </div>
                    </div>
                    <div class="col-12">

                    </div>
                    <div class="col-12">
                        <label>Subject</label>
                        <textarea class="messageTextArea" rows="1" [maxLength]="250" formControlName="Subject"
                            (input)="adjustHeight($event)"></textarea>
                    </div>
                    <div class="col-12">
                        <label class="form-label">Body</label>
                        <textarea class="messageTextArea" rows="4" [maxLength]="2000" formControlName="Message"
                            (input)="adjustHeight($event)"></textarea>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer p-3 pt-1 pb-1">
            <button class="btn Btn-primary btn-w" (click)="onSave(true)">Send Email</button>
        </div>
    </form>
</div>
</div>


\\--------------------------------------ReToolTabService.ts---------------------------------------------------

import { Injectable } from '@angular/core';
import { FormControlStatus, FormGroup } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, catchError, filter, map, Observable, of, Subject, Subscription, switchMap } from 'rxjs';
import { environment } from '../../../../environments/environment';
import { AppConstants } from '../../../shared/constants/app.constants';
import { ReToolConstants } from '../constants/re-tool.constants';
import { ActionEnum } from '../models/action-enum';
import { Cover } from '../models/cover';
import { PropertyEquipmentLocation } from '../models/property-equipment-location';
import { PropertyFireLocation } from '../models/property-fire-location';
import { PropertyLocation } from '../models/property-location';
import { PropertyValue } from '../models/property-value';
import { SavePropertyLocationRequestModel } from '../models/savePropertyRequest';
import { ReToolService } from './re-tool.service';
import { OilGasPetrochemical } from '../models/oil-gas-petrochemical';

interface DynamicAccessiblePropertyItem {
  ULId?: string;
  Address: string;
  City?: string;
  StateProvince: string;
  LocationAddressMapId?: number;
}

@Injectable({
  providedIn: 'root'
})
export class ReToolTabService {
  reviewRequestId: number;
  private dataSourceSubject$ = new Subject<{ event: string, payload: any }>();
  public hasFormChange$ = new BehaviorSubject<boolean>(false);
  public hasFormSavedSuccessfull$ = new BehaviorSubject<boolean>(false);
  public selectedCurrencyUnitSubject$ = new BehaviorSubject<any>(null);
  private selectedLocAddressData = new BehaviorSubject<any>(null);
  selectedLocAddressData$ = this.selectedLocAddressData.asObservable();
  formStatus: FormControlStatus = ReToolConstants.valid;
  subscription: Subscription | undefined = new Subscription();
  propertyLocationForm: FormGroup;
  tabIndex: number;
  subTabIndex: number;
  productLineId: number = 0;
  currencyUnitValid: boolean = true;
  allPropertyValuesDeleted: boolean = false;
  private locAddressPopupClosedSubject: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  locAddressPopupClosedSubject$ = this.locAddressPopupClosedSubject.asObservable();
  isOverAllRatingRequired: boolean;

  public coverLocationsDataSubject: BehaviorSubject<any> = new BehaviorSubject<any>('');
  coverLocationsDataSubject$ = this.coverLocationsDataSubject.asObservable();

  public overAllRatingACIAQIDataSubject: BehaviorSubject<{}> = new BehaviorSubject<{}>({ overAllRatingACI: null, overAllRatingAQI: null});
  overAllRatingACIAQIDataSubject$ = this.overAllRatingACIAQIDataSubject.asObservable();
  
  propertyLocationColumns: string[] = [
    "LocationName",
    "StreetAddress",
    "CityName",
    "StateName",
    "CountryName",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "BusinessInterruptionValue",
    "BusinessInterruptionOtherValue",
    "IndemnityPeriod",
    "PayRollValue",
    "PayRollDayValue",
    "TotalTE",
    "Total",
    "Delete"
  ];

  occupancyColumns: string[] = [
    "LocationName",
    "StreetAddress",
    "CountryName",
    "OccupancyGroup",
    "OccupancyType",
    "OccupancyCode",
    "Hazard",
    "EquipmentBreakdown",
    "GroupBuildingArea",
    "BuildingValuePerSquareFeet",
    "AutomaticSprinklersPercentage",
    "AutomaticSprinklersNeededPercentage"
  ];

  generalPropertyColumns: string[] = [
    "LocationName",
    "StreetAddress",
    "CountryName",
    "NormalLossExpectancy",
    "ProbableMaximumLoss",
    "MaximumForeseeableLoss",
    "HumanElementCalculated",
    "ConstructionCalculated",
    "ConstructionHazards",
    "DetectionSecurity",
    "AutomaticSprinklers",
    "FireWaterSupply",
    "FireManualResponse",
    "SpecialHazards",
    "EquipmentHazards",
    "ExternalExposures",
    "BusinessInterruptionCalculated",
    "PropertyDamageIndexUpdated",
    "PropertyDamageIndexAdjusted",
    "BusinessInterruptionIndexCalculated",
    "LocationQualityIndexCalculated",
    "ConfidenceIndex",
    "LossPreventionSource",
    "LossPreventionDate",
    "LossPreventionComments"
  ];

  ogpcColumns: string[] = [
    "LocationName",
    "StreetAddress",
    "CountryName",
    "PhysicalAttributes",
    "ProcessAndEquipment",
    "HydrocarbonStorage",
    "PlantProtection",
    "ProcessSafety",
    "OperationalFactors",
    "AssetIntegrity",
    "Maintenance",
    "BusinessInterruption",
    "PropertyDamageIndex",
    "IndexAdjustedBy",
    "BusinessInterruptionIndex",
    "LocationQualityIndex",
    "ConfidenceIndex",
    "SourceInformation",
    "Date",
    "Comments"
  ];

  normalLossExpectancyColumns: string[] = [
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "NormalLossCompare",
    "NormalLossScenario",
    "NormalLossDeficiencyDriven",
    "NormalLossPropertyDamage",
    "NormalLossOtherPropertyDamage",
    "TotalPDNLE",
    "NormalLossBusinessInterruption",
    "NormalLossInterBusinessInterruption",
    "NormalLossOtherTimeElement",
    "TotalTE",
    "NLEActual",
    "NormalLossIndemnityPeriodBI",
    "IPFactTotal",

  ];

  probableMaximumLossColumns: string[] = [
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "PML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  maximumForeseeableLossColumns: string[] = [
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "MFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  equipmentProbableMaximumLossColumns: string[] = [
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "EBPML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  equipmentMaximumForeseeableLossColumns: string[] = [
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "EBMFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  coverColumns: string[] = [
    "ReportedBuildingValue",
    "ReportedContentsValue",
    "ReportedTotalPD",
    "ReportedTotalBivalue",
    "ReportedTIV",
    "ReviewedBuilding",
    "ReviewedContents",
    "ReviewedTotalPD",
    "ReviewedTotalBI",
    "ReviewedTIV",
    "ReviewedPercentageBuilding",
    "ReviewedPercentageContents",
    "ReviewedPercentageTotalPD",
    "ReviewedPercentageTotalBI",
    "ReviewedPercentageTIV",
    "TimeElementExcluded",
    "RecommendedReviewFrequency",
    "RecommendedAccountPercentageTIV",
    "OccupancyGroupTIV",
    "OccupancyTypeTIV",
    "OccupancyCodeTIV",
    "HazardTIV",
    "EquipmentBreakdownTIV",
    "DeviationTIV",
    "IsHazardTIVUpdated",
    "IsEquipmentBreakdownUpdatedTIV",
    "OccupancyGroupHighestHazardReview",
    "OccupancyTypeHighestHazardReview",
    "OccupancyCodeHighestHazardReview",
    "OccupancyHighestHazardReview",
    "EquipmentBreakdownHazardReview",
    "DeviationHighestHazardReview",
    "IsHighestHazardReviewUpdated",
    "IsEBRHighestHazardReviewUpdated",
    "IsHazardUpdated",
    "IsEquipmentBreakdownUpdated",
    "Interdependency",
    "ContingentTimeElement",
    "QualityOfSupplyChainInfo",
    "SCRiskMgmt",
    "SupplyChainConfidence"
  ];

  activityColumns: string[] = [
    "Subject",
    "TaskDueDate",
    "AssignedTo",
    "AssignedStatusId",
    "Description"
  ];

  constructor(private reToolService: ReToolService, private toastr: ToastrService) { }

  emit(event: string, ds: any) {
    this.dataSourceSubject$.next({ event: event, payload: ds });
  }

  on(event: string): Observable<any> {
    return this.dataSourceSubject$.asObservable().pipe(
      filter(e => e.event === event),
      map(e => e.payload)
    );
  }

  setUpPropertyValuesData(isGeneralProperty: boolean = false): Observable<any> {
    return this.reToolService.getLocationProperties(this.reviewRequestId, isGeneralProperty, this.isOverAllRatingRequired);
  }

  setUpOgpcValuesData(): Observable<any> {
    return this.reToolService.getOilGasPetrochemicalData(this.reviewRequestId);
  }

  setUpCoverWithPropertyValuesData(): Observable<any> {
    return this.reToolService.getCoverWithPropertyValues(this.reviewRequestId);
  }

  setUpPropertyValueWithDefaultData(): Observable<any> {
    return of([new PropertyValue(), new PropertyValue()]);
  }

  setUpPropertyFireLocationData(): Observable<any> {
    return this.reToolService.getPropertyFireLocations(this.reviewRequestId, this.isOverAllRatingRequired);
  }

  setUpProbableMaximumLossData(): Observable<any> {
    return this.reToolService.getProbableMaximumLoss(this.reviewRequestId);
  }

  setUpMaximumForeseeableLossData(): Observable<any> {
    return this.reToolService.getMaximumForeseeableLoss(this.reviewRequestId);
  }

  setUpPropertyEquipmentLocationData(): Observable<any> {
    return this.reToolService.getPropertyEquipmentBreakdownLocations(this.reviewRequestId, this.isOverAllRatingRequired);
  }

  // The purpose of this logic is to maintain a parent and sub tab association
  // which can be used individually as a single value to determine tab relationships
  encodeTabIndex(parentTabIndex: number, subTabIndex: number): number {
    if (parentTabIndex === 0) return 1;
    return ((parentTabIndex << 3) | subTabIndex);
  }

  // This is to fetch parent and sub tab indexes out of association value
  // it could be removed if not needed in future
  decodeTabIndex(encodedTabIndexValue: number): { parentTabIndex: number, subtabIndex: number } {
    const parentIndex = (encodedTabIndexValue >> 3) & 7;//shift right by 3 bits and mask with 7 (0111)
    const subIndex = encodedTabIndexValue & 7;
    return { parentTabIndex: parentIndex, subtabIndex: subIndex } as any;
  }

  saveUpdateDeleteAndFetchThePropertyValueFormData(data: SavePropertyLocationRequestModel, isTabChange: boolean = false): Observable<any> {
    const isGeneralProperty = false;
    const postUrl = `${environment.baseUrl}Property`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}/${this.isOverAllRatingRequired}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  updatePropertyLocationFormData(data: PropertyLocation[], isTabChange: boolean = false, isGeneralProperty: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/UpdateOccupancyOrGeneralProperty`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}/${this.isOverAllRatingRequired}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  updateOilGasPetrochemicalFormData(data: OilGasPetrochemical[], isTabChange: boolean = false, isGeneralProperty: boolean = false): Observable<any> {
    const postUrl = null;
    const getUrl = null;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchThePropertyFireLocationFormData(data: PropertyFireLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/AddOrUpdatePropertyFireLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${this.reviewRequestId}&isOverAllRatingRequired=${this.isOverAllRatingRequired}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  private saveUpdateAndFetchTheLatestActiveFormData<T>(postUrl: string, data: any, getUrl: string): Observable<T> {
    return this.reToolService.post(postUrl, data).pipe(
      switchMap((postResponse) => {
        if (getUrl) {
          return this.reToolService.get<T>(getUrl);
        } else {
          return of(postResponse as T);
        }
      }),
      catchError(this.reToolService.handleError)
    )
  }

  showErrorMessage(message: string, action: string) {
    this.toastr.error(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  showSuccessMessage(message: string, action: string) {
    this.toastr.success(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  actionStateChange(formGroup: FormGroup) {
    this.subscription?.add(
      formGroup?.get('Action').valueChanges.subscribe(value => {
        this.hasFormChange$.next((value != ActionEnum.IsSaved))
      })
    );
  }

  saveUpdateAndFetchThePropertyEquipmentLocationFormData(data: PropertyEquipmentLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/UpdatePropertyEquipmentBreakdownLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${this.reviewRequestId}&isOverAllRatingRequired=${this.isOverAllRatingRequired}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchTheCoverFormData(data: Cover, isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/SaveOrUpdatePropertyAccountCover`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyAccountCover/${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  setUpAcivityTaskDetailValuesData(): Observable<any> {
    return this.reToolService.getAllActivityTaskDetails();
  }

  mergePropertyValueData<T extends DynamicAccessiblePropertyItem>(data: T[]): T[] {
    const mergeMap = new Map<string, Partial<T & {
      StreetAddresses: string[],
      CityNames: string[],
      StateProvinces: string[],
      LocationAddressMapIds: number[]
    }>>();

    let mergedData: any[] = [];
    data.forEach(item => {
      const key = item.ULId;

      if (!mergeMap.has(key)) {
        mergeMap.set(key, {
          ...item,
          StreetAddresses: [],
          CityNames: [],
          StateProvinces: [],
          LocationAddressMapIds: []
        });
      }

      const existing = mergeMap.get(key);
      existing.StreetAddresses.push(item.Address);
      existing.CityNames.push(item.City);
      existing.StateProvinces.push(item.StateProvince);
      if (item instanceof PropertyValue)
        existing.LocationAddressMapIds.push(item.LocationAddressMapId);
    });

    mergedData = Array.from(mergeMap.values());
    mergedData.forEach(x => this.setAddressAndToolTip(x));
    return mergedData;
  }

  // handle tooltip and final grid values
  setAddressAndToolTip(data: any) {
    if (data.Action === ActionEnum.IsDeleted) return;
    
    if (Array.from(new Set(data.StreetAddresses)).length > 1
      || Array.from(new Set(data.CityNames)).length > 1
      || Array.from(new Set(data.StateProvinces)).length > 1) {
      data.Address = ReToolConstants.multiple;
    } else {
      data.Address = data.StreetAddresses[0];
    }

    if (Array.from(new Set(data.CityNames)).length > 1) {
      data.City = ReToolConstants.multiple;
    } else {
      data.City = data.CityNames[0];
    }

    if (Array.from(new Set(data.StateProvinces)).length > 1) {
      data.StateProvince = ReToolConstants.multiple;
    } else {
      data.StateProvince = data.StateProvinces[0];
    }

    const streetAddressToolTip = [];
    streetAddressToolTip.push(data.StreetAddresses.map((address, index) => {
      const city = data.CityNames[index] ? `${data.CityNames[index]}, ` : '';
      const state = data.StateProvinces[index] ? `${data.StateProvinces[index]}, ` : '';

      return `${address}, ${city} ${state}`.trim().replace(/.$/,"");
    }));

    data.StreetAddressToolTip = [...new Set(streetAddressToolTip[0])].join('\n');
  }

  SetLocAddressSelectedData(data: any[]) {
    this.selectedLocAddressData.next(data);
  }
  
  setLocAddressPopupClosedSubject(status: boolean): void {
    this.locAddressPopupClosedSubject.next(status);
  }
  
  getSupplyChainUpdatedValue(supplyChainControlValue : any) : number {
    if(supplyChainControlValue == 1){
      return 1;
    }
    else if(supplyChainControlValue == 2){
      return 3;
    }
    else if(supplyChainControlValue == 3 || supplyChainControlValue == 4){
      return 5;
    }
    else{
      return null;
    }
  }
}

\\--------------------------------------------ReToolService.ts----------------------------------------

import { Injectable } from '@angular/core';
import { PropertyValue } from '../models/property-value';
import { catchError, Observable, Subject, tap, throwError } from 'rxjs';
import { ReToolConstants } from '../constants/re-tool.constants';
import { environment } from '../../../../environments/environment';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { NormalLossExpectancy } from '../models/normal-loss-expectancy';
import { ProbableMaximumLoss } from '../models/probable-maximum-loss';
import { MaximumForeseeableLoss } from '../models/maximum-foreseeable-loss';
import { EquipmentProbableMaximumLoss } from '../models/equipment-probable-maximum-loss';
import { PropertyMasterDataTypeEnum } from '../models/property-master-data-type-enum';
import { GeneralPropertyWeightResponse } from '../models/general-property-weight-response';
import { Cover } from '../models/cover';
import { PropertyLocationImportRequest } from '../models/property-location-import-request';
import { LocationFilterModel } from '../../loc-address/models/location-name-address';
import { OilGasPetrochemical } from '../models/oil-gas-petrochemical';
import { Activity } from '../models/activity';

const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type': 'application/json'
  })
};

@Injectable({
  providedIn: 'root'
})

export class ReToolService {
  public addNewLocationSubject = new Subject<void>();
  addNewLocation$ = this.addNewLocationSubject.asObservable();
  public currencyUnitSubject = new Subject<any>();
  currencyUnit$ = this.currencyUnitSubject.asObservable();
  public locationApiDataSubscribe$ = new Subject<any>();
  public countrySearchSubject$ = new Subject<any>();
  public emailSearchSubject$ = new Subject<any>();
  public humanElementRiskFactorSubject = new Subject<any>();
  humanElementRiskFactor$ = this.humanElementRiskFactorSubject.asObservable();
  private importDataSubject = new Subject<{ locationData: any, propertyValueData: any }>();
  importData$ = this.importDataSubject.asObservable();
  public emptyPropertyLocationSubject$ = new Subject<any>();

  private readonly httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    })
  };

  constructor(private http: HttpClient) { }

  getLocationProperties(reviewRequestId: number, isGeneralProperty: boolean, isOverAllRatingRequired: boolean): Observable<PropertyValue[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetAllProperty/${reviewRequestId}/${isGeneralProperty}/${isOverAllRatingRequired}`);
  }

  getCoverWithPropertyValues(reviewRequestId: number): Observable<Cover> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyAccountCover/${reviewRequestId}`);
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return `row-${rowIndex}_dataKey-${dataId}_${columnName}_${popUp}`;
  }

  getLocationByAddress(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetAddressSearch/${query}`, httpOptions);
  }

  getLocationByGeoCode(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetGeoCode/${query}`, httpOptions);
  }

  getPropertyMaster(type: PropertyMasterDataTypeEnum): Observable<any> {
    let params = new HttpParams();
    if (type == PropertyMasterDataTypeEnum.HumanElementRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.BIRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.Cover) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    const options = {
      ...this.httpOptions,
      params
    }

    if (type === PropertyMasterDataTypeEnum.CurrencyAndUnit) {
      return this.http.get<any>(`${environment.baseUrl}Property`, options)
        .pipe(
          tap(data => this.currencyUnitSubject.next(data)),
          catchError(error => {
            return throwError(() => new Error(error.message));
          })
        );
    }
    else
      return this.http.get<any>(`${environment.baseUrl}Property`, options);
  };

  getEnumPropertyName = (value: number): string => {
    return PropertyMasterDataTypeEnum[value];
  };

  getOccupancyGroup(productLine: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetRequestCompleteMaster/?productLine=${productLine}`, httpOptions);
  }

  getOccupancyType(occupancyGroupId: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetOccupancyType/?occupancyGroupId=${occupancyGroupId}`, httpOptions);
  }

  // Generic POST request for submitting the data to the api
  // could update once backend API ready
  post<T>(url: string, body: any): Observable<T> {
    return this.http.post<any>(url, body, this.httpOptions).pipe(catchError(this.handleError));
  }

  //Generic GET request for api calling
  // could update once backend API ready
  get<T>(url: string): Observable<T> {
    return this.http.get<T>(url, this.httpOptions).pipe(
      tap((response) => response),
      catchError(this.handleError)
    );
  }

  handleError(error: any): Observable<never> {
    throw new Error(error.message);
  }

  getPropertyFireLocations(reviewRequestId: number, isOverAllRatingRequired: boolean = false): Observable<NormalLossExpectancy[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${reviewRequestId}&isOverAllRatingRequired=${isOverAllRatingRequired}`);
  }

  getProbableMaximumLoss(reviewRequestId: number): Observable<ProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getOilGasPetrochemicalData(reviewRequestId: number): Observable<OilGasPetrochemical[]> {
    return this.get<any>(`${environment.baseUrl}OilGasPetrochemical/${reviewRequestId}`);
  }

  getMaximumForeseeableLoss(reviewRequestId: number): Observable<MaximumForeseeableLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getPropertyEquipmentBreakdownLocations(reviewRequestId: number, isOverAllRatingRequired: boolean = false): Observable<EquipmentProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${reviewRequestId}&isOverAllRatingRequired=${isOverAllRatingRequired}`);
  }

  getGeneralPropertyWeight(occupancyCodes: any): Observable<GeneralPropertyWeightResponse[]> {
    return this.post<GeneralPropertyWeightResponse[]>(`${environment.baseUrl}Master/GetGeneralPropertyWeight`, occupancyCodes);
  }

  importData(data: any, propertyValueData: any) {
    this.importDataSubject.next({ locationData: data, propertyValueData: propertyValueData });
  }

  importPropertyLocations(data: PropertyLocationImportRequest[]): any {
    const apiURL = `${environment.baseUrl}Property/PropertyLocationImport`;
    return this.http.post(apiURL, data);
  }

  searchLocationByName(locationFilter: LocationFilterModel) {
    const body = JSON.stringify(locationFilter);
    return this.http.post<any>(`${environment.baseUrl}Property/GetLocationSuggestionByName`, body, httpOptions);
  }

  searchCountryName(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Property/GetCountrySuggestionByName/${query}`, httpOptions);
  }

  getAllActivityTaskDetails(): Observable<Activity[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetAllActivityTaskDetails`);
  }

  getAllRequestReviewDetails(reviewRequestId: number) {
    return this.http.get<any>(`${environment.baseUrl}ReviewRequest/GetReviewRequestById/${reviewRequestId}`, httpOptions);
  }

  GetCoverCompleteReviewMailIds(propertyAccountId: any) {
    return this.http.get<any>(`${environment.baseUrl}Property/GetCoverCompleteReviewMailIds/${propertyAccountId}`, httpOptions);
  }

  sendCoverCompleteMailRequest(requestModel: any): Observable<any> {
    const body = JSON.stringify(requestModel);
    return this.http.post<any>(`${environment.baseUrl}Property/SendCoverCompleteMailRequest`, body, httpOptions);
  }

  getFxRate(fromCurrency: string, pricingDate: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Master/${fromCurrency}/${pricingDate}`, httpOptions);
  }

  getActiveUserNameAndEmail(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Property/GetActiveUserNameAndEmail/${query}`, httpOptions);
  }
}

//-------------------------CompleteReviewEmail.ts---------------------------------------

export class CompleteReviewEmail {
    RiskEngineer: string = ''
    UnderWritter: string = ''
    PeerReviewer: string = ''
    MflReviewer: string = ''
    AdditionalEngineer: string = ''
    CCUserMailIds: string = '';
    Subject: string = '';
    Message: string = '';
    AccountName: string = '';
    PropertyAccountId: number = 0;
    ReviewRequestId: number = 0;
    CCMailIds: string[] = [];
}
