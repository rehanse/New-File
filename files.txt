import { Component } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { ReToolService } from '../../../service/re-tool.service';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { NormalLossExpectancy } from '../../../models/normal-loss-expectancy';
import { MatTableDataSource } from '@angular/material/table';
import { Subscription } from 'rxjs/internal/Subscription';
import { FormDataSource } from '../../../models/form-data-source';
import { SubTabEncodedEnum } from '../../../models/re-tool-tabs-enum';
import { ReToolConstants } from '../../../constants/re-tool.constants';
import { Utility } from '../../../utility/mapper-util';
import { GridRowRecord } from '../../../models/grid-row-record';
import { ActionEnum } from '../../../models/action-enum';
import { ReToolAddressGroupingService } from '../../../service/re-tool-address-grouping.service';

@Component({
  selector: 're-tool-normal-loss-expectancy',
  templateUrl: './normal-loss-expectancy.component.html',
  styleUrl: './normal-loss-expectancy.component.css'
})
export class NormalLossExpectancyComponent {
  normalLossExpectancyForm: FormGroup;
  normmalLossExpectancyData: NormalLossExpectancy[] = [];
  normmalLossExpectancyDataSource: MatTableDataSource<AbstractControl>;
  normmalLossExpectancyDisplayedColumns: string[] = [];
  subscription: Subscription | undefined = new Subscription();
  showHideColumn: boolean = true

  constructor(private fb: FormBuilder, private reToolService: ReToolService, private reToolTabService: ReToolTabService,
    private addressGrouping:ReToolAddressGroupingService
  ) { }

  ngOnInit() {
    this.initializeForm();
    this.reToolTabService.emit('onFormComponentInit', { encodedTabIndex: SubTabEncodedEnum.NormalLossExpectancy });
  }

  initializeForm() {
    this.subscription?.add(this.reToolTabService.on('onInitializeNormmalLossExpectancyData').subscribe({
      next: (event: FormDataSource) => {
        if (event.data) {
          this.normmalLossExpectancyDisplayedColumns = event?.columns;
          this.normmalLossExpectancyData = event?.data;
          this.normmalLossExpectancyData = this.reToolTabService
          .mergePropertyValueData<NormalLossExpectancy>(event?.data);
          this.normalLossExpectancyForm = this.fb.group({
            rows: this.fb.array([])
          });
          this.initializeDataSource();
          this.normmalLossExpectancyDataSource = new MatTableDataSource(this.tableRowsControls);
          this.defaultHideColumns();
          this.reToolTabService.hasFormChange$.next(false);
        }
      },
      error: (error) => { }
    }));
    
    this.subscription?.add(
      this.reToolTabService.on('onProcessingSave').subscribe((event) => {
        this.normalLossExpectancyForm.markAllAsTouched();
        this.normalLossExpectancyForm.markAsPristine();
        this.normalLossExpectancyForm.updateValueAndValidity();
        this.reToolTabService.formStatus = this.normalLossExpectancyForm.status;

        const hasFormError = this.normalLossExpectancyForm.status === ReToolConstants.invalid;

        if (hasFormError) {
          this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
        } else {
          this.reToolTabService.emit('onSaveFormData', { formData: this.getNormalExpectancyFormData, subTabIndex: 0, tabInfo: event?.tabInfo, isTabChange: event?.isTabChange });
        }
      }));
  }

  initializeDataSource() {
    // process and group the data
    this.setRows(this.normmalLossExpectancyData);
  }

  setRows(groupedData:any[]) {
    const rows = this.getFormArray();
      groupedData?.forEach(data => {
      const row = this.createRow(data);
      this.totalPDNLE(row);
      this.totalTimeElement(row);
      this.calculateTotal(row);
      this.calculateIPFactTotal(row);
      this.setupCalculationSubscribers(row);
      rows.push(row);
      this.reToolTabService.actionStateChange(row);
      row.get('NormalLossCompare').setValue(data.NormalLossCompare?.toString());
    });
  }

  createRow(data: NormalLossExpectancy): FormGroup {
    return this.fb.group({
      ULId: new FormControl({ value: data.ULId || '', disabled: true }),
      LocationName: new FormControl({ value: data.LocationName || '', disabled: true }),
      Address: new FormControl({ value: data.Address || [''], disabled: true }),
      Country: new FormControl({ value: data.Country || '', disabled: true }),
      PropertyFireLocationId: new FormControl({ value: data.PropertyFireLocationId || 0, disabled: true }),
      GroupBuildingArea: new FormControl({ value: Utility.formatGBA(data.GroupBuildingArea) || null, disabled: true }),
      BuildingValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.BuildingValue) || '0.0', disabled: true }),
      EquipmentValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.EquipmentValue) || '0.0', disabled: true }),
      InventoryValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.InventoryValue) || '0.0', disabled: true }),
      OtherValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.OtherValue) || '0.0', disabled: true }),
      TotalPD: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(this.calculateTotalPD(data.BuildingValue, data.EquipmentValue, data.InventoryValue, data.OtherValue)) || '0.0', disabled: true }),
      AnnualBusinessInterruptionValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.AnnualBusinessInterruptionValue) || '0.0', disabled: true }),
      IndemnityPeriodMonth: new FormControl({ value: data.IndemnityPeriodMonth || '0', disabled: true }),
      PayRollValue: new FormControl({ value: Utility.commaSepratedValueForDisabledInput(data.PayRollValue) || '0.0', disabled: true }),
      PayRollDayValue: new FormControl({ value: data.PayRollDayValue || '0', disabled: true }),
      NormalLossCompare: new FormControl({ value: data.NormalLossCompare, disabled: false }),
      NormalLossScenario: new FormControl({ value: data.NormalLossScenario || '', disabled: false }, Validators.required),
      NormalLossDeficiencyDriven: new FormControl({ value: data.NormalLossDeficiencyDriven || false, disabled: false }, Validators.required),
      NormalLossPropertyDamage: new FormControl({ value: Utility.formatNumber(data.NormalLossPropertyDamage) || '0.0', disabled: false }),
      NormalLossOtherPropertyDamage: new FormControl({ value: Utility.formatNumber(data.NormalLossOtherPropertyDamage) || '0.0', disabled: false }),
      TotalPDNLE: new FormControl({ value: this.calculateTotalPDNLE(data.NormalLossPropertyDamage, data.NormalLossOtherPropertyDamage) || '0.0', disabled: true }),
      NormalLossBusinessInterruption: new FormControl({ value: Utility.formatNumber(data.NormalLossBusinessInterruption) || '0.0', disabled: false }),
      NormalLossInterBusinessInterruption: new FormControl({ value: Utility.formatNumber(data.NormalLossInterBusinessInterruption) || '0.0', disabled: false }),
      NormalLossOtherTimeElement: new FormControl({ value: Utility.formatNumber(data.NormalLossOtherTimeElement) || '0.0', disabled: false }),
      TotalTE: new FormControl({ value: this.calculateTotalTE(data.NormalLossBusinessInterruption, data.NormalLossInterBusinessInterruption, data.NormalLossOtherTimeElement) || '0.0', disabled: true }),
      NLEActual: new FormControl({ value: this.calculateTotalPDNLE(data.NormalLossPropertyDamage, data.NormalLossOtherPropertyDamage) + this.calculateTotalTE(data.NormalLossBusinessInterruption, data.NormalLossInterBusinessInterruption, data.NormalLossOtherTimeElement) || '0.0', disabled: true }),
      NormalLossIndemnityPeriodBI: new FormControl({ value: Utility.formatNumber(data.NormalLossIndemnityPeriodBI) || '0.0', disabled: false }),
      IPFactTotal: new FormControl({ value: data.IPFactTotal || '0.0', disabled: true }),
      VerCol: data.VerCol,
      LocationId: data.LocationId,
      Action: new FormControl(data.Action || ActionEnum.IsSaved),
      PropertyLocationId: new FormControl(data.PropertyLocationId),
      StreetAddressToolTip: new FormControl(data.StreetAddressToolTip),
      City: new FormControl(data.City || ['']),
      StateProvinces: new FormControl(data.StateProvince || [''])
    });
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return this.reToolService.generateFormElementIdAttribute(rowIndex, dataId, columnName);
  }

  get tableRowsControls() {
    return this.getFormArray().controls;
  }

  ShowHideColumns() {
    if (this.showHideColumn) {
      this.defaultHideColumns();
    } else {
      this.defaultShowColumns();
    }
  }

  calculateIpFactorTotal(propertyDamage: any, otherPropertyDamage: any): any {
    return propertyDamage + otherPropertyDamage;
  }

  clearSelection(rowIndex: number) {
    const row = this.getFormGroup(rowIndex);
    row.get('NormalLossCompare').setValue(null, { emitEvent: false });
    row.patchValue({ ['Action']: ActionEnum.IsModified });
  }

  getFormArray(): FormArray {
    return (this.normalLossExpectancyForm.get('rows') as FormArray);
  }

  onCellValueChange(event: Event, column: FormControl) {
    const cellElement = event.target as HTMLElement;
    const response: GridRowRecord = this.getGidRowRecordDetail(cellElement?.id);
    response.value = column.value;

    const row = this.getFormArray().at(response.rowIndex);
    row.patchValue({
      [response.columnName]: response.columnName === 'NormalLossDeficiencyDriven'
        ? (response.value === 'true' ? true : false)
        : response.value,
      ['Action']: ActionEnum.IsModified
    });
  }

  onSubmit() {
    this.normalLossExpectancyForm.markAllAsTouched();
    this.reToolTabService.formStatus = this.normalLossExpectancyForm.status;

    if (this.normalLossExpectancyForm.status == ReToolConstants.valid) {
      this.reToolTabService.emit('onSaveFormData', { formData: this.getNormalExpectancyFormData, subTabIndex: 0 });
    } else {
      this.reToolTabService.showErrorMessage(ReToolConstants.requiredFieldsValidationMessage, '');
    }
  }

  private get getNormalExpectancyFormData(): NormalLossExpectancy[] {
    return this.getFormArray()?.getRawValue() as NormalLossExpectancy[];
  }

  private defaultShowColumns() {
    this.showHideColumn = true;
    this.normmalLossExpectancyDisplayedColumns = [...this.reToolTabService.normalLossExpectancyColumns]
  }

  private defaultHideColumns() {
    this.showHideColumn = false;
    this.normmalLossExpectancyDisplayedColumns = this.normmalLossExpectancyDisplayedColumns.filter(col =>
      col !== ReToolConstants.groupBuildingArea && col !== ReToolConstants.buildingValue && col !== ReToolConstants.equipmentValue && col !== ReToolConstants.inventoryValue && col !== ReToolConstants.otherValue &&
      col !== ReToolConstants.totalPD && col !== ReToolConstants.annualBusinessInterruptionValue && col !== ReToolConstants.indemnityPeriodMonth && col !== ReToolConstants.payRollValue &&
      col !== ReToolConstants.payRollDayValue && col !== ReToolConstants.countryName && col !== ReToolConstants.address
    );
  }

  private calculateTotalPD(buildingValue: any, equipmentValue: any, inventoryValue: any, otherValue: any): any {
    return buildingValue + equipmentValue + inventoryValue + otherValue;
  }

  private calculateTotalPDNLE(propertyDamage: any, otherPropertyDamage: any): any {
    return propertyDamage + otherPropertyDamage;
  }

  private calculateTotalTE(businessInterruption: any, interBusinessInterruption: any, otherTimeElement: any): any {
    return businessInterruption + interBusinessInterruption + otherTimeElement;
  }

  private totalPDNLE(row: FormGroup<any>) {
    const propertyDamageValue = parseFloat(Utility.removeComma(row.get('NormalLossPropertyDamage')?.value)) || 0.0;
    const otherPropertyDamageValue = parseFloat(Utility.removeComma(row.get('NormalLossOtherPropertyDamage')?.value)) || 0.0;
    const totalPDNLE = propertyDamageValue + otherPropertyDamageValue;
    row.get('TotalPDNLE').setValue(Utility.commaSepratedValueForDisabledInput(totalPDNLE), { emitEvent: false });
    this.calculateTotal(row);
  }

  private setUpPropertyDamagedIndexTotalCalculation(row: FormGroup<any>) {
    const propertyDamageValue = row.get('NormalLossPropertyDamage')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.totalPDNLE(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(propertyDamageValue);

    const otherPropertyDamageValue = row.get('NormalLossOtherPropertyDamage')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.totalPDNLE(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(otherPropertyDamageValue);
  }

  private totalTimeElement(row: FormGroup<any>) {
    const businessInterruptionValue = parseFloat(Utility.removeComma(row.get('NormalLossBusinessInterruption')?.value)) || 0.0;
    const interBusinessInterruptionValue = parseFloat(Utility.removeComma(row.get('NormalLossInterBusinessInterruption')?.value)) || 0.0;
    const otherTimeElementValue = parseFloat(Utility.removeComma(row.get('NormalLossOtherTimeElement')?.value)) || 0.0;
    const totalTimeElement = businessInterruptionValue + interBusinessInterruptionValue + otherTimeElementValue;
    row.get('TotalTE').setValue(Utility.commaSepratedValueForDisabledInput(totalTimeElement), { emitEvent: false });
    this.calculateTotal(row);
  }

  private setUpTimeElementIndexTotalCalculation(row: FormGroup<any>) {
    const businessInterruptionValue = row.get('NormalLossBusinessInterruption')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.totalTimeElement(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(businessInterruptionValue);

    const interBusinessInterruptionValue = row.get('NormalLossInterBusinessInterruption')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.totalTimeElement(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(interBusinessInterruptionValue);

    const otherTimeElementValue = row.get('NormalLossOtherTimeElement')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.totalTimeElement(row)
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(otherTimeElementValue);
  }

  private setUpTotalCalculation(row: FormGroup<any>) {
    const totalPDNLE = row.get('TotalPDNLE')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotal(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(totalPDNLE);

    const totalTE = row.get('TotalTE')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateTotal(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(totalTE);
  }

  private calculateTotal(row: FormGroup<any>) {
    const totalPDNLEValue = parseFloat(Utility.removeComma(row.get('TotalPDNLE')?.value)) || 0.0;
    const totalTEValue = parseFloat(Utility.removeComma(row.get('TotalTE')?.value)) || 0.0;
    const total = totalPDNLEValue + totalTEValue;
    row.get('NLEActual').setValue(Utility.commaSepratedValueForDisabledInput(total), { emitEvent: false });
    this.calculateIPFactTotal(row);
  }

  private setUpIpFactTotalCalculation(row: FormGroup<any>) {
    const ipFactBIValue = row.get('NormalLossIndemnityPeriodBI')?.valueChanges.subscribe(({
      next: (res) => {
        if (res !== undefined && res !== null) {
          this.calculateIPFactTotal(row);
        }
      },
      error: (error) => {
        throw new error;
      },
    }));
    this.subscription?.add(ipFactBIValue);
  }

  private calculateIPFactTotal(row: FormGroup<any>) {
    const ipFactBIValue = parseFloat(Utility.removeComma(row.get('NormalLossIndemnityPeriodBI')?.value)) || 0.0;
    let ipFactTotal = 0.0;

    if (ipFactBIValue > 0.0) {
      const totalPDNLEValue = parseFloat(Utility.removeComma(row.get('TotalPDNLE')?.value)) || 0.0;
      const totalTimeElementValue = parseFloat(Utility.removeComma(row.get('TotalTE')?.value)) || 0.0;
      ipFactTotal = totalPDNLEValue + totalTimeElementValue;
    }
    row.get('IPFactTotal').setValue(Utility.commaSepratedValueForDisabledInput(ipFactTotal || 0.0), { emitEvent: false });
  }

  private setupCalculationSubscribers(row: FormGroup<any>) {
    this.setUpPropertyDamagedIndexTotalCalculation(row);
    this.setUpTimeElementIndexTotalCalculation(row);
    this.setUpTotalCalculation(row);
    this.setUpIpFactTotalCalculation(row);
  }

  private getFormGroup(rowIndex: number): FormGroup {
    return (this.getFormArray()
      .at(rowIndex) as FormGroup);
  }

  private getGidRowRecordDetail(input: string): GridRowRecord {

    const [rowPart, idPart, column, popup] = input.split('_');

    const record: GridRowRecord = {
      rowIndex: parseInt(rowPart.split('-')[1]),
      columnName: column,
      rowPKId: parseInt(idPart.split('-')[1]),
      value: '',
      popup: popup
    };

    return record;
  }

  ngOnDestroy() {
    if (this.subscription) {
      this.subscription?.unsubscribe();
    }
  }
}
-------------------------------------------------------------------
import { ActionEnum } from "./action-enum";

export class NormalLossExpectancy {
    PropertyFireLocationId?: number = 0;
    ULId?: string = '';
    LocationId: number;
    FullAddress: string = '';
    LocationName:string = '';
    Country:string = '';
    GroupBuildingArea: number = 0;
    BuildingValue: number = 0;
    EquipmentValue: number = 0;
    InventoryValue: number = 0;
    OtherValue: number = 0;
    TotalPD?: number = 0;
    AnnualBusinessInterruptionValue?: number = 0;
    IndemnityPeriodMonth: number = 0;
    PayRollValue: number = 0;
    PayRollDayValue: number = 0;
    NormalLossCompare: string = '';
    NormalLossScenario: string = '';
    NormalLossDeficiencyDriven: boolean = false;
    NormalLossPropertyDamage: number = 0;
    NormalLossOtherPropertyDamage: number = 0;
    TotalPDNLE: number = 0;
    NormalLossBusinessInterruption: number = 0;
    NormalLossInterBusinessInterruption: number = 0;
    NormalLossOtherTimeElement: number = 0;
    TotalTE: number = 0;
    NLEActual: number = 0;
    NormalLossIndemnityPeriodBI: number = 0;
    IPFactTotal: number = 0;
    Action: ActionEnum = ActionEnum.IsNewRecord;
    VerCol: string = ''
    PropertyLocationId: number = 0; 
    Address: string;
    StreetAddressToolTip?: any = [];
    City: string = '';
    StateProvince: string = '';
}
-------------------------------------------------------
import { Injectable } from '@angular/core';
import { ReToolConstants } from '../constants/re-tool.constants';

@Injectable({
  providedIn: 'root'
})
export class ReToolAddressGroupingService {

  private groupByLocationKeys: string[] = [ReToolConstants.locationKeyULID, ReToolConstants.locationKeyLocationName, ReToolConstants.locationKeyCountry];
  private addressField: string = ReToolConstants.locationAddressField;
  private cityField = ReToolConstants.locationCityField;
  private stateField = ReToolConstants.locationStateField;
  private tooltipField = ReToolConstants.locationStreetAddressToolTip;

  addressGroupingData(data: any[]): any[] {
    const groupedData: any = {};

    data.forEach((item) => {
      const locationKey = this.groupByLocationKeys.map(key => item[key]).join('_');

      if (!groupedData[locationKey]) {
        groupedData[locationKey] = {
          ...item,
          [this.addressField]: [],
          [this.cityField]: [],
          [this.stateField]: [],
          [this.tooltipField]: this.generateToolTip(
            [item[this.addressField]],
            [item[this.cityField]],
            [item[this.stateField]]
          )
        };
      }

      // if multiple address exist for same location, append then into array
      if (item[this.addressField]) {
        groupedData[locationKey][this.addressField].push(item[this.addressField]);
        groupedData[locationKey][this.cityField].push(item[this.cityField]);
        groupedData[locationKey][this.stateField].push(item[this.stateField]);
      } else {
        groupedData[locationKey][this.addressField] = item[this.addressField];
        groupedData[locationKey][this.cityField] = item[this.cityField];
        groupedData[locationKey][this.stateField] = item[this.stateField];
      }

    });

    // process each group and prepare final output
    return Object.keys(groupedData).map(locationKey => {
      const locationData = groupedData[locationKey];
      // handle the "Multiple" field and generate tooltip with new lines
      const addressTooltip = this.generateToolTip(locationData[this.addressField], locationData[this.cityField], locationData[this.stateField]);
      locationData[this.addressField] = locationData[this.addressField].length > 1 ? ReToolConstants.multiple : locationData[this.addressField];
      locationData[this.cityField] = locationData[this.cityField].length > 1 ? ReToolConstants.multiple : locationData[this.cityField];
      locationData[this.stateField] = locationData[this.stateField].length > 1 ? ReToolConstants.multiple : locationData[this.stateField];

      // set tooltip for merging records
      locationData[this.tooltipField] = addressTooltip;
      return locationData;
    });
  }

  generateToolTip(addresses: string[], cities: string[], states: string[]): any {
    const streetAddressToolTip = [];
    streetAddressToolTip.push(addresses.map((address, index) => {
      const city = cities[index] ? `${cities[index]}` : '';
      const state = states[index] ? `${states[index]}` : '';
      return `${address}${city ? ', ' + city : city}${state ? ', ' + state : state}`.trim();
    }));
    return addresses[ReToolConstants.locationStreetAddressToolTip] = [...new Set(streetAddressToolTip[0])].join('\n');
  }
}
---------------------------------------------------
import { Injectable } from '@angular/core';
import { PropertyValue } from '../models/property-value';
import { catchError, Observable, Subject, tap, throwError } from 'rxjs';
import { ReToolConstants } from '../constants/re-tool.constants';
import { environment } from '../../../../environments/environment';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { NormalLossExpectancy } from '../models/normal-loss-expectancy';
import { ProbableMaximumLoss } from '../models/probable-maximum-loss';
import { MaximumForeseeableLoss } from '../models/maximum-foreseeable-loss';
import { EquipmentProbableMaximumLoss } from '../models/equipment-probable-maximum-loss';
import { PropertyMasterDataTypeEnum } from '../models/property-master-data-type-enum';
import { GeneralPropertyWeightResponse } from '../models/general-property-weight-response';
import { Cover } from '../models/cover';
import { PropertyLocationImportRequest } from '../models/property-location-import-request';
import { LocationFilterModel } from '../../loc-address/models/location-name-address';

const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type': 'application/json'
  })
};

@Injectable({
  providedIn: 'root'
})

export class ReToolService {
  public addNewLocationSubject = new Subject<void>();
  addNewLocation$ = this.addNewLocationSubject.asObservable();
  public currencyUnitSubject = new Subject<any>();
  currencyUnit$ = this.currencyUnitSubject.asObservable();
  public locationApiDataSubscribe$ = new Subject<any>();
  public countrySearchSubject$ = new Subject<any>();
  public humanElementRiskFactorSubject = new Subject<any>();
  humanElementRiskFactor$ = this.humanElementRiskFactorSubject.asObservable();
  private importDataSubject = new Subject<{ locationData: any, propertyValueData: any }>();
  importData$ = this.importDataSubject.asObservable();

  private readonly httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    })
  };

  constructor(private http: HttpClient) { }

  getLocationProperties(reviewRequestId: number, isGeneralProperty: boolean): Observable<PropertyValue[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetAllProperty/${reviewRequestId}/${isGeneralProperty}`);
  }

  getCoverWithPropertyValues(reviewRequestId: number): Observable<Cover> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyAccountCover/${reviewRequestId}`);
  }

  generateFormElementIdAttribute(rowIndex: number, dataId: number, columnName: string, popUp?: string): string {
    return `row-${rowIndex}_dataKey-${dataId}_${columnName}_${popUp}`;
  }

  getLocationByAddress(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetAddressSearch/${query}`, httpOptions);
  }

  getLocationByGeoCode(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Location/GetGeoCode/${query}`, httpOptions);
  }

  getPropertyMaster(type: PropertyMasterDataTypeEnum): Observable<any> {
    let params = new HttpParams();
    if (type == PropertyMasterDataTypeEnum.HumanElementRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.BIRiskFactor) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    if (type == PropertyMasterDataTypeEnum.Cover) {
      params = params.set(ReToolConstants.propertyMasterType, this.getEnumPropertyName(type)); // add query parameter if provided by user
    }

    const options = {
      ...this.httpOptions,
      params
    }

    if (type === PropertyMasterDataTypeEnum.CurrencyAndUnit) {
      return this.http.get<any>(`${environment.baseUrl}Property`, options)
        .pipe(
          tap(data => this.currencyUnitSubject.next(data)),
          catchError(error => {
            return throwError(() => new Error(error.message));
          })
        );
    }
    else
      return this.http.get<any>(`${environment.baseUrl}Property`, options);
  };

  getEnumPropertyName = (value: number): string => {
    return PropertyMasterDataTypeEnum[value];
  };

  getOccupancyGroup(productLine: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetRequestCompleteMaster/?productLine=${productLine}`, httpOptions);
  }

  getOccupancyType(occupancyGroupId: any) {
    return this.http.get<any>(`${environment.baseUrl}Master/GetOccupancyType/?occupancyGroupId=${occupancyGroupId}`, httpOptions);
  }

  // Generic POST request for submitting the data to the api
  // could update once backend API ready
  post<T>(url: string, body: any): Observable<T> {
    return this.http.post<any>(url, body, this.httpOptions).pipe(catchError(this.handleError));
  }

  //Generic GET request for api calling
  // could update once backend API ready
  get<T>(url: string): Observable<T> {
    return this.http.get<T>(url, this.httpOptions).pipe(
      tap((response) => response),
      catchError(this.handleError)
    );
  }

  handleError(error: any): Observable<never> {
    throw new Error(error.message);
  }

  getPropertyFireLocations(reviewRequestId: number): Observable<NormalLossExpectancy[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${reviewRequestId}`);
  }

  getProbableMaximumLoss(reviewRequestId: number): Observable<ProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getMaximumForeseeableLoss(reviewRequestId: number): Observable<MaximumForeseeableLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetNormalLossExpectancy?reviewRequestId=${reviewRequestId}`);
  }

  getPropertyEquipmentBreakdownLocations(reviewRequestId: number): Observable<EquipmentProbableMaximumLoss[]> {
    return this.get<any>(`${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${reviewRequestId}`);
  }

  getGeneralPropertyWeight(occupancyCodes: any): Observable<GeneralPropertyWeightResponse[]> {
    return this.post<GeneralPropertyWeightResponse[]>(`${environment.baseUrl}Master/GetGeneralPropertyWeight`, occupancyCodes);
  }

  importData(data: any, propertyValueData: any) {
    this.importDataSubject.next({ locationData: data, propertyValueData: propertyValueData });
  }

  importPropertyLocations(data: PropertyLocationImportRequest[]): any {
    const apiURL = `${environment.baseUrl}Property/PropertyLocationImport`;
    return this.http.post(apiURL, data);
  }

  searchLocationByName(locationFilter: LocationFilterModel) {
    const body = JSON.stringify(locationFilter);
    return this.http.post<any>(`${environment.baseUrl}Property/GetLocationSuggestionByName`, body, httpOptions);
  }
  
  searchCountryName(query: string): Observable<any> {
    return this.http.get<any>(`${environment.baseUrl}Property/GetCountrySuggestionByName/${query}`, httpOptions);
  }
}
--------------------------------------------------------
import { Injectable } from '@angular/core';
import { FormControlStatus, FormGroup } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, catchError, filter, map, Observable, of, Subject, Subscription, switchMap } from 'rxjs';
import { environment } from '../../../../environments/environment';
import { AppConstants } from '../../../shared/constants/app.constants';
import { ReToolConstants } from '../constants/re-tool.constants';
import { ActionEnum } from '../models/action-enum';
import { Cover } from '../models/cover';
import { PropertyEquipmentLocation } from '../models/property-equipment-location';
import { PropertyFireLocation } from '../models/property-fire-location';
import { PropertyLocation } from '../models/property-location';
import { PropertyValue } from '../models/property-value';
import { SavePropertyLocationRequestModel } from '../models/savePropertyRequest';
import { ReToolService } from './re-tool.service';

interface DynamicAccessiblePropertyItem {
  ULId?: string;
  Address: string;
  City?: string;
  StateProvince: string;
  LocationAddressMapId?: number;
}

@Injectable({
  providedIn: 'root'
})
export class ReToolTabService {
  reviewRequestId: number;
  private dataSourceSubject$ = new Subject<{ event: string, payload: any }>();
  public hasFormChange$ = new BehaviorSubject<boolean>(false);
  public selectedCurrencyUnitSubject$ = new BehaviorSubject<any>(null);
  private selectedLocAddressData = new BehaviorSubject<any>(null);
  selectedLocAddressData$ = this.selectedLocAddressData.asObservable();
  formStatus: FormControlStatus = ReToolConstants.valid;
  subscription: Subscription | undefined = new Subscription();
  propertyLocationForm: FormGroup;
  tabIndex: number;
  subTabIndex: number;
  productLineId: number = 0;
  currencyUnitValid: boolean = true;
  allPropertyValuesDeleted: boolean = false;
  private locAddressPopupClosedSubject: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  locAddressPopupClosedSubject$ =this.locAddressPopupClosedSubject.asObservable();

  propertyLocationColumns: string[] = [
    "ULID",
    "LocationName",
    "StreetAddress",
    "CityName",
    "StateName",
    "CountryName",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "BusinessInterruptionValue",
    "BusinessInterruptionOtherValue",
    "IndemnityPeriod",
    "PayRollValue",
    "PayRollDayValue",
    "TotalTE",
    "Total",
    "Delete"
  ];

  occupancyColumns: string[] = [
    "ULID",
    "LocationName",
    "StreetAddress",
    "CountryName",
    "OccupancyGroup",
    "OccupancyType",
    "OccupancyCode",
    "Hazard",
    "EquipmentBreakdown",
    "GroupBuildingArea",
    "AutomaticSprinklersPercentage",
    "AutomaticSprinklersNeededPercentage"
  ];

  generalPropertyColumns: string[] = [
    "PropertyLocationId",
    "FullAddress",
    "CountryName",
    "NormalLossExpectancy",
    "ProbableMaximumLoss",
    "MaximumForeseeableLoss",
    "HumanElementCalculated",
    "ConstructionCalculated",
    "ConstructionHazards",
    "DetectionSecurity",
    "AutomaticSprinklers",
    "FireWaterSupply",
    "FireManualResponse",
    "SpecialHazards",
    "EquipmentHazards",
    "ExternalExposures",
    "BusinessInterruptionCalculated",
    "PropertyDamageIndexUpdated",
    "PropertyDamageIndexAdjusted",
    "BusinessInterruptionIndexCalculated",
    "LocationQualityIndexCalculated",
    "ConfidenceIndex",
    "LossPreventionSource",
    "LossPreventionDate",
    "LossPreventionComments"
  ];

  normalLossExpectancyColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "NormalLossCompare",
    "NormalLossScenario",
    "NormalLossDeficiencyDriven",
    "NormalLossPropertyDamage",
    "NormalLossOtherPropertyDamage",
    "TotalPDNLE",
    "NormalLossBusinessInterruption",
    "NormalLossInterBusinessInterruption",
    "NormalLossOtherTimeElement",
    "TotalTE",
    "NLEActual",
    "NormalLossIndemnityPeriodBI",
    "IPFactTotal",

  ];

  probableMaximumLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "PML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  maximumForeseeableLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "MFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal",
  ];

  equipmentProbableMaximumLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "ProbableLossCompare",
    "ProbableLossScenario",
    "ProbableLossPropertyDamage",
    "ProbableLossOtherPropertyDamage",
    "TotalPDPML",
    "ProbableLossBusinessInterruption",
    "ProbableLossInterBusinessInterruption",
    "ProbableLossOtherTimeElement",
    "TotalTE",
    "EBPML",
    "ProbableLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  equipmentMaximumForeseeableLossColumns: string[] = [
    "ULID",
    "FullAddress",
    "StreetAddress",
    "CountryName",
    "GroupBuildingArea",
    "BuildingValue",
    "EquipmentValue",
    "InventoryValue",
    "OtherValue",
    "TotalPD",
    "AnnualBusinessInterruptionValue",
    "IndemnityPeriodMonth",
    "PayRollValue",
    "PayRollDayValue",
    "MaximumLossCompare",
    "MaximumLossScenario",
    "MaximumLossPropertyDamage",
    "MaximumLossOtherPropertyDamage",
    "TotalPDMFL",
    "MaximumLossBusinessInterruption",
    "MaximumLossInterBusinessInterruption",
    "MaximumLossOtherTimeElement",
    "TotalTE",
    "EBMFL",
    "MaximumLossIndemnityPeriodBI",
    "IPFactTotal"
  ];

  coverColumns: string[] = [
    "ReportedBuildingValue",
    "ReportedContentsValue",
    "ReportedTotalPD",
    "ReportedTotalBivalue",
    "ReportedTIV",
    "ReviewedBuilding",
    "ReviewedContents",
    "ReviewedTotalPD",
    "ReviewedTotalBI",
    "ReviewedTIV",
    "ReviewedPercentageBuilding",
    "ReviewedPercentageContents",
    "ReviewedPercentageTotalPD",
    "ReviewedPercentageTotalBI",
    "ReviewedPercentageTIV",
    "TimeElementExcluded",
    "RecommendedReviewFrequency",
    "RecommendedAccountPercentageTIV",
    "OccupancyGroupTIV",
    "OccupancyTypeTIV",
    "OccupancyCodeTIV",
    "HazardTIV",
    "EquipmentBreakdownTIV",
    "DeviationTIV",
    "IsHazardTIVUpdated",
    "IsEquipmentBreakdownUpdatedTIV",
    "OccupancyGroupHighestHazardReview",
    "OccupancyTypeHighestHazardReview",
    "OccupancyCodeHighestHazardReview",
    "OccupancyHighestHazardReview",
    "EquipmentBreakdownHazardReview",
    "DeviationHighestHazardReview",
    "IsHighestHazardReviewUpdated",
    "IsEBRHighestHazardReviewUpdated",
    "IsHazardUpdated",
    "IsEquipmentBreakdownUpdated",
    "Interdependency",
    "ContingentTimeElement",
    "QualityOfSupplyChainInfo",
    "SCRiskMgmt",
    "SupplyChainConfidence"
  ];

  constructor(private reToolService: ReToolService, private toastr: ToastrService) { }

  emit(event: string, ds: any) {
    this.dataSourceSubject$.next({ event: event, payload: ds });
  }

  on(event: string): Observable<any> {
    return this.dataSourceSubject$.asObservable().pipe(
      filter(e => e.event === event),
      map(e => e.payload)
    );
  }

  setUpPropertyValuesData(isGeneralProperty: boolean = false): Observable<any> {
    return this.reToolService.getLocationProperties(this.reviewRequestId, isGeneralProperty);
  }

  setUpCoverWithPropertyValuesData(): Observable<any> {
    return this.reToolService.getCoverWithPropertyValues(this.reviewRequestId);
  }

  setUpPropertyValueWithDefaultData(): Observable<any> {
    return of([new PropertyValue(), new PropertyValue()]);
  }

  setUpPropertyFireLocationData(): Observable<any> {
    return this.reToolService.getPropertyFireLocations(this.reviewRequestId);
  }

  setUpProbableMaximumLossData(): Observable<any> {
    return this.reToolService.getProbableMaximumLoss(this.reviewRequestId);
  }

  setUpMaximumForeseeableLossData(): Observable<any> {
    return this.reToolService.getMaximumForeseeableLoss(this.reviewRequestId);
  }

  setUpPropertyEquipmentLocationData(): Observable<any> {
    return this.reToolService.getPropertyEquipmentBreakdownLocations(this.reviewRequestId);
  }

  // The purpose of this logic is to maintain a parent and sub tab association
  // which can be used individually as a single value to determine tab relationships
  encodeTabIndex(parentTabIndex: number, subTabIndex: number): number {
    if (parentTabIndex === 0) return 1;
    return ((parentTabIndex << 3) | subTabIndex);
  }

  // This is to fetch parent and sub tab indexes out of association value
  // it could be removed if not needed in future
  decodeTabIndex(encodedTabIndexValue: number): { parentTabIndex: number, subtabIndex: number } {
    const parentIndex = (encodedTabIndexValue >> 3) & 7;//shift right by 3 bits and mask with 7 (0111)
    const subIndex = encodedTabIndexValue & 7;
    return { parentTabIndex: parentIndex, subtabIndex: subIndex } as any;
  }

  saveUpdateDeleteAndFetchThePropertyValueFormData(data: SavePropertyLocationRequestModel, isTabChange: boolean = false): Observable<any> {
    const isGeneralProperty = false;
    const postUrl = `${environment.baseUrl}Property`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  updatePropertyLocationFormData(data: PropertyLocation[], isTabChange: boolean = false): Observable<any> {
    const isGeneralProperty = false;
    const postUrl = `${environment.baseUrl}Property/UpdateOccupancy`;
    const getUrl = `${environment.baseUrl}Property/GetAllProperty/${this.reviewRequestId}/${isGeneralProperty}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchThePropertyFireLocationFormData(data: PropertyFireLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/AddOrUpdatePropertyFireLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyFireLocations?reviewRequestId=${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  private saveUpdateAndFetchTheLatestActiveFormData<T>(postUrl: string, data: any, getUrl: string): Observable<T> {
    return this.reToolService.post(postUrl, data).pipe(
      switchMap((postResponse) => {
        if (getUrl) {
          return this.reToolService.get<T>(getUrl);
        } else {
          return of(postResponse as T);
        }
      }),
      catchError(this.reToolService.handleError)
    )
  }

  showErrorMessage(message: string, action: string) {
    this.toastr.error(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  showSuccessMessage(message: string, action: string) {
    this.toastr.success(message, '', {
      timeOut: AppConstants.snackbarDuration,
      closeButton: true,
      progressBar: true,
      positionClass: "toast-top-right"
    });
  }

  actionStateChange(formGroup: FormGroup) {
    this.subscription?.add(
      formGroup?.get('Action').valueChanges.subscribe(value => {
        this.hasFormChange$.next((value != ActionEnum.IsSaved))
      })
    );
  }

  saveUpdateAndFetchThePropertyEquipmentLocationFormData(data: PropertyEquipmentLocation[], isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/UpdatePropertyEquipmentBreakdownLocation`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyEquipmentBreakdownLocations?reviewRequestId=${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  saveUpdateAndFetchTheCoverFormData(data: Cover, isTabChange: boolean = false): Observable<any> {
    const postUrl = `${environment.baseUrl}Property/SaveOrUpdatePropertyAccountCover`;
    const getUrl = `${environment.baseUrl}Property/GetPropertyAccountCover/${this.reviewRequestId}`;
    return this.saveUpdateAndFetchTheLatestActiveFormData(postUrl, data, !isTabChange ? getUrl : null);
  }

  mergePropertyValueData<T extends DynamicAccessiblePropertyItem>(data: T[]): T[] {
    const mergeMap = new Map<string, Partial<T & {
      StreetAddresses: string[],
      CityNames: string[],
      StateProvinces: string[],
      LocationAddressMapIds: number[]
    }>>();

    let mergedData: any[] = [];
    data.forEach(item => {
      const key = item.ULId;

      if (!mergeMap.has(key)) {
        mergeMap.set(key, {
          ...item,
          StreetAddresses: [],
          CityNames: [],
          StateProvinces: [],
          LocationAddressMapIds: []
        });
      }

      const existing = mergeMap.get(key);
      existing.StreetAddresses.push(item.Address);
      existing.CityNames.push(item.City);
      existing.StateProvinces.push(item.StateProvince);
      if (item instanceof PropertyValue)
        existing.LocationAddressMapIds.push(item.LocationAddressMapId);
    });

    mergedData = Array.from(mergeMap.values());
    mergedData.forEach(x => this.setAddressAndToolTip(x));
    return mergedData;
  }

  // handle tooltip and final grid values
  setAddressAndToolTip(data: any) {
    if (Array.from(new Set(data.StreetAddresses)).length > 1
      || Array.from(new Set(data.CityNames)).length > 1
      || Array.from(new Set(data.StateProvinces)).length > 1) {
      data.Address = ReToolConstants.multiple;
    } else {
      data.Address = data.StreetAddresses[0];
    }

    if (Array.from(new Set(data.CityNames)).length > 1) {
      data.City = ReToolConstants.multiple;
    } else {
      data.City = data.CityNames[0];
    }

    if (Array.from(new Set(data.StateProvinces)).length > 1) {
      data.StateProvince = ReToolConstants.multiple;
    } else {
      data.StateProvince = data.StateProvinces[0];
    }

    const streetAddressToolTip = [];
    streetAddressToolTip.push(data.StreetAddresses.map((address, index) => {
      const city = data.CityNames[index] ? `${data.CityNames[index]}, ` : '';
      return `${address}, ${city} ${data.StateProvinces[index]}`
    }));

    data.StreetAddressToolTip = [...new Set(streetAddressToolTip[0])].join('\n');
  }

  SetLocAddressSelectedData(data: any[]) {
    this.selectedLocAddressData.next(data);
  }
  
  setLocAddressPopupClosedSubject(status: boolean): void {
    this.locAddressPopupClosedSubject.next(status);
  }
}
