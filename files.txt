import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { OccupancyComponent } from './occupancy.component';
import { ReToolService } from '../../../service/re-tool.service';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { FormBuilder, ReactiveFormsModule, FormArray, FormGroup } from '@angular/forms';
import { MatTableModule } from '@angular/material/table';
import { of, Subscription } from 'rxjs';
import { ActionEnum } from '../../../models/action-enum';
import { ReToolConstants } from '../../../constants/re-tool.constants';

describe('OccupancyComponent', () => {
  let component: OccupancyComponent;
  let fixture: ComponentFixture<OccupancyComponent>;
  let mockReToolService: jasmine.SpyObj<ReToolService>;
  let mockReToolTabService: jasmine.SpyObj<ReToolTabService>;
  const fb = new FormBuilder();

  // Mock Data
  const mockOccupancyGroupResponse = {
    occupancyGroups: [{ value: '1', text: 'Group 1' }],
    hazard: [{ value: 'h1', text: 'Hazard 1' }],
    equipmentBreakdown: [{ value: 'e1', text: 'Equipment 1' }]
  };

  const initialFormData = {
    data: [{
      ULId: '1',
      LocationName: 'Test Location',
      OccupancyGroup: '1',
      OccupancyType: 'type1',
      Hazard: 'h1',
      EquipmentBreakdown: 'e1',
      Action: ActionEnum.IsSaved
    }],
    columns: ['LocationName', 'OccupancyGroup']
  };

  beforeEach(async () => {
    // Create spy objects with required methods
    mockReToolService = jasmine.createSpyObj('ReToolService', 
      ['getOccupancyGroup', 'getOccupancyType']);
    mockReToolTabService = jasmine.createSpyObj('ReToolTabService',
      ['on', 'emit', 'mergePropertyValueData', 'showErrorMessage', 'actionStateChange']);

    // Configure service mocks
    mockReToolService.getOccupancyGroup.and.returnValue(of(mockOccupancyGroupResponse));
    mockReToolService.getOccupancyType.and.returnValue(of([
      { 
        value: 'type1', 
        dependentValue: { 
          occupancyTypeCode: 'code1',
          hazard: 'h1',
          equipmentBreakdown: 'e1'
        }
      }
    ]));
    
    mockReToolTabService.on.and.callFake((eventName: string) => {
      if (eventName === 'onInitializeOccupancyData') {
        return of(initialFormData);
      }
      return of();
    });

    await TestBed.configureTestingModule({
      imports: [ReactiveFormsModule, MatTableModule],
      declarations: [OccupancyComponent],
      providers: [
        { provide: ReToolService, useValue: mockReToolService },
        { provide: ReToolTabService, useValue: mockReToolTabService },
        FormBuilder
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(OccupancyComponent);
    component = fixture.componentInstance;
    
    // Initialize component with fakeAsync to handle ngOnInit
    fixture.detectChanges();
  });

  afterEach(() => {
    if (component.subscription) {
      component.subscription.unsubscribe();
    }
  });

  describe('Component Initialization', () => {
    it('should create the component', () => {
      expect(component).toBeTruthy();
    });

    it('should initialize form with data from service', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      expect(component.occupancyForm).toBeDefined();
      expect(component.occupancyDataSource).toBeTruthy();
      expect(component.tableRowsControls.length).toBe(1);
    }));
  });

  describe('Form Interactions', () => {
    it('should create valid form row structure', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0) as FormGroup;
      expect(row.get('LocationName').disabled).toBeTrue();
      expect(row.get('OccupancyGroup').validator).toBeTruthy();
      expect(row.get('OccupancyType').validator).toBeTruthy();
    }));

    it('should handle occupancy group change', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      component.changeOccupancyGroup(0, '1');
      tick();
      
      const row = component.getFormArray().at(0);
      expect(row.get('OccupancyType').value).toBe(ReToolConstants.blank);
      expect(mockReToolService.getOccupancyType).toHaveBeenCalledWith('1');
    }));

    it('should handle occupancy type change', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      component.changeOccupancyType(0, 'type1');
      tick();
      
      const row = component.getFormArray().at(0);
      expect(row.get('Hazard').value).toBe('h1');
      expect(row.get('EquipmentBreakdown').value).toBe('e1');
      expect(row.get('Action').value).toBe(ActionEnum.IsModified);
    }));
  });

  describe('Form Validation', () => {
    it('should mark form invalid when required fields are empty', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0);
      row.get('OccupancyGroup').setValue('');
      row.get('OccupancyGroup').markAsTouched();
      component.occupancyForm.updateValueAndValidity();
      tick();
      
      expect(component.occupancyForm.invalid).toBeTrue();
      expect(mockReToolTabService.formStatus).toBe('INVALID');
    }));

    it('should show error message on invalid submission', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0);
      row.get('OccupancyGroup').setValue('');
      component.occupancyForm.updateValueAndValidity();
      tick();
      
      component.onSubmit();
      expect(mockReToolTabService.showErrorMessage).toHaveBeenCalledWith(
        ReToolConstants.requiredFieldsValidationMessage, 
        ''
      );
    }));
  });

  describe('Data Operations', () => {
    it('should emit valid form data on submission', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0);
      row.get('OccupancyGroup').setValue('valid');
      component.occupancyForm.updateValueAndValidity();
      tick();
      
      component.onSubmit();
      expect(mockReToolTabService.emit).toHaveBeenCalledWith(
        'onSaveFormData', 
        jasmine.objectContaining({ formData: jasmine.any(Array) })
      );
    }));

    it('should update highlights when values differ from default', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0);
      component.rowValuesMap.set(0, {
        OccupancyTypeList: [{ 
          value: 'type1', 
          dependentValue: { 
            hazard: 'default', 
            equipmentBreakdown: 'default' 
          } 
        }]
      });
      
      row.get('Hazard').setValue('modified');
      component.updateHighlight(0, 'type1', 'Hazard');
      tick();
      
      expect(row.controls['Hazard'][ReToolConstants.isHighlighted]).toBeTrue();
      expect(row.get('IsHazardUpdated').value).toBeTrue();
    }));
  });

  describe('Lifecycle Hooks', () => {
    it('should unsubscribe on destroy', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      spyOn(component.subscription, 'unsubscribe');
      component.ngOnDestroy();
      expect(component.subscription.unsubscribe).toHaveBeenCalled();
    }));
  });

  describe('Private Methods', () => {
    it('should access form array through private method', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const formArray = component['getFormArray']();
      expect(formArray).toBeInstanceOf(FormArray);
      expect(formArray.length).toBe(1);
    }));

    it('should disable dropdown controls when no group selected', fakeAsync(() => {
      component.ngOnInit();
      tick();
      
      const row = component.getFormArray().at(0);
      component['disableDropdownControl'](row, true);
      expect(row.get('Hazard').disabled).toBeTrue();
      expect(row.get('EquipmentBreakdown').disabled).toBeTrue();
    }));
  });
});
