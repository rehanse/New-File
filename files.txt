using FluentValidation;
using NCalc;

public class MyModel
{
    public decimal A { get; set; }  // Numeric value
    public string B { get; set; }   // Expression (e.g. "Building + 10 * 20")
    public decimal C { get; set; }  // Building value
}

public class MyModelValidator : AbstractValidator<MyModel>
{
    public MyModelValidator()
    {
        RuleFor(x => x)
            .Must(BeValidExpression)
            .WithMessage("A must equal the evaluated expression from B.");
    }

    private bool BeValidExpression(MyModel model)
    {
        if (string.IsNullOrWhiteSpace(model.B))
            return false;

        try
        {
            // Replace "Building" keyword with actual C value
            string expressionText = model.B.Replace("Building", model.C.ToString());

            // Use NCalc to evaluate
            var expr = new Expression(expressionText);
            var result = expr.Evaluate();

            if (result == null)
                return false;

            decimal evaluatedValue = Convert.ToDecimal(result);

            return model.A == evaluatedValue;
        }
        catch
        {
            return false; // Invalid expression
        }
    }
}

var model = new MyModel
{
    A = 250,
    B = "Building + 10 * 20",
    C = 50
};

var validator = new MyModelValidator();
var result = validator.Validate(model);

if (!result.IsValid)
{
    foreach (var error in result.Errors)
    {
        Console.WriteLine(error.ErrorMessage);
    }
}
else
{
    Console.WriteLine("Validation Passed âœ…");
}
