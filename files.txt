Great question ğŸ‘

You basically have three realistic options for evaluating the formula in property B and comparing it with A in FluentValidation. Let me break them down with pros & cons so you can pick the best for your use case:


---

ğŸ”¹ 1. NCalc (Recommended in most cases)

var expr = new Expression("Building + 10 * 20");
expr.Parameters["Building"] = 50; // safer than string replace
var result = expr.Evaluate(); // â†’ 250

âœ… Pros

Designed for evaluating mathematical & logical expressions.

Safe (sandboxed, no arbitrary C# execution).

Supports variables, functions, custom parameters.

Easy to integrate and maintain.


âŒ Cons

External NuGet dependency (NCalc).

Slightly slower than raw C# (but negligible for most apps).


ğŸ‘‰ Best for: Business rules, configurable expressions, enterprise apps.


---

ğŸ”¹ 2. DataTable.Compute (Hacky)

using System.Data;

string expr = "50 + 10 * 20"; 
var result = new DataTable().Compute(expr, null); // â†’ 250

âœ… Pros

Built-in (no extra library).

Quick & simple for math-only expressions.


âŒ Cons

No support for variables (youâ€™d need manual string replace).

Vulnerable to injection if input isnâ€™t sanitized.

Limited functionality compared to NCalc.


ğŸ‘‰ Best for: Small apps, throwaway scripts, quick hacks.


---

ğŸ”¹ 3. Roslyn C# Scripting

using Microsoft.CodeAnalysis.CSharp.Scripting;

var result = await CSharpScript.EvaluateAsync<int>("Building + 10 * 20",
    globals: new { Building = 50 });

âœ… Pros

Runs real C# (full power of the language).

Extremely flexible.


âŒ Cons

Heavy (requires Roslyn packages).

Security risk: executing arbitrary C# code if input is untrusted.

Overkill for just formulas like "Building + 10 * 20".


ğŸ‘‰ Best for: Advanced scenarios where users really need full C# scripting (like Excel formulas or DSLs).


---

âœ… My Recommendation

For your case (A should equal evaluated B where C is the variable):
ğŸ‘‰ Use NCalc with parameter substitution.

Itâ€™s safe, expressive, and built exactly for this type of rule validation.
Example (better than string replace ğŸ‘‡):

private bool BeValidExpression(MyModel model)
{
    try
    {
        var expr = new Expression(model.B);
        expr.Parameters["Building"] = model.C;

        var result = expr.Evaluate();
        return Convert.ToDecimal(result) == model.A;
    }
    catch
    {
        return false;
    }
}


---

Do you want me to extend this and show you a complete FluentValidation rule with NCalc parameters (instead of doing string replace) so you get the cleanest & safest version?

