it('should get general property weight', () => {
    const mockData: GeneralProperty[] = [
      {
        ULId: '1',
        Address: '123 Street',
        City: 'New York',
        Country: 'USA',
        OccupancyTypeCode: 5,
        OccupancyGroupCode: 10
      },
      {
        ULId: '2',
        Address: '456 Avenue',
        City: 'Los Angeles',
        Country: 'USA',
        OccupancyTypeCode: 3,
        OccupancyGroupCode: 7
      }
    ];

    spyOn(Utility, 'isValidOccupancyTypeCode').and.callFake(code => code === 5);

    const mockResponse: GeneralPropertyWeightResponse[] = [
      { 
        generalPropertyGroupCodeWeightId: 1,
        occupancyGroupId: 10,
        groupCode: 'G1',
        typeCode: 5,
        weight: 50 
      },
      { 
        generalPropertyGroupCodeWeightId: 2,
        occupancyGroupId: 7,
        groupCode: 'G2',
        typeCode: 3,
        weight: 30 
      }
    ];

    reToolServiceSpy.getGeneralPropertyWeight.and.returnValue(of(mockResponse));
    spyOn(component as any, 'buildRedistributedWeightData');
    spyOn(reToolCalculationServiceSpy, 'setRedistributionWeights').and.callThrough();

    component['getGeneralPropertyWeight'](mockData as any);

    expect(reToolServiceSpy.getGeneralPropertyWeight).toHaveBeenCalledWith([5, 7]);
    expect(component['weights']).toEqual(mockResponse);
    expect(component['buildRedistributedWeightData']).toHaveBeenCalledWith(mockData);
    expect(reToolCalculationServiceSpy.setRedistributionWeights).toHaveBeenCalledWith(component['redistributionWeights']);
    
    // Instead of calling a private method, spy on a public one that calls `calculate`
    spyOn(reToolCalculationServiceSpy, 'performCalculation').and.callThrough(); // Assuming `performCalculation` is public
    expect(reToolCalculationServiceSpy.performCalculation).toHaveBeenCalled();
});
