import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { OccupancyComponent } from './occupancy.component';
import { ReToolService } from '../../../service/re-tool.service';
import { ReToolTabService } from '../../../service/re-tool-tab.service';
import { FormBuilder, ReactiveFormsModule, FormControlStatus, FormArray } from '@angular/forms';
import { MatTableModule } from '@angular/material/table';
import { MasterDataModel } from '../../../../dashboard/models/master-data';
import { Occupancy } from '../../../models/occupancy';
import { of, Subscription } from 'rxjs';
import { ActionEnum } from '../../../models/action-enum';
import { SubTabEncodedEnum } from '../../../models/re-tool-tabs-enum';
import { ReToolConstants } from '../../../constants/re-tool.constants';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

describe('OccupancyComponent', () => {
  let component: OccupancyComponent;
  let fixture: ComponentFixture<OccupancyComponent>;
  let mockReToolService: jasmine.SpyObj<ReToolService>;
  let mockReToolTabService: jasmine.SpyObj<ReToolTabService>;
  const fb = new FormBuilder();

  beforeEach(async () => {
    mockReToolService = jasmine.createSpyObj('ReToolService', ['getOccupancyGroup', 'getOccupancyType']);
    mockReToolTabService = jasmine.createSpyObj('ReToolTabService', 
      ['on', 'emit', 'mergePropertyValueData', 'showErrorMessage', 'actionStateChange']);
    
    await TestBed.configureTestingModule({
      imports: [
        ReactiveFormsModule,
        MatTableModule,
        MatFormFieldModule,
        MatInputModule,
        MatSelectModule,
        BrowserAnimationsModule
      ],
      declarations: [OccupancyComponent],
      providers: [
        { provide: ReToolService, useValue: mockReToolService },
        { provide: ReToolTabService, useValue: mockReToolTabService },
        FormBuilder
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(OccupancyComponent);
    component = fixture.componentInstance;
    
    // Mock initial data load
    mockReToolTabService.on.and.callFake((eventName: string) => {
      if (eventName === 'onInitializeOccupancyData') {
        return of({
          data: [createMockOccupancy()],
          columns: ['LocationName']
        });
      }
      return of();
    });
  });

  afterEach(() => {
    if (component.subscription) {
      component.subscription.unsubscribe();
    }
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  describe('Initialization', () => {
    it('should initialize form and load occupancy groups on ngOnInit', fakeAsync(() => {
      const mockMasterData: MasterDataModel[] = [{ value: '1', text: 'Group 1' }];
      mockReToolService.getOccupancyGroup.and.returnValue(of({
        occupancyGroups: mockMasterData,
        hazard: [],
        equipmentBreakdown: []
      }));
      
      component.ngOnInit();
      tick();
      fixture.detectChanges();
      
      expect(mockReToolService.getOccupancyGroup).toHaveBeenCalledWith(0);
      expect(mockReToolTabService.emit).toHaveBeenCalledWith(
        'onFormComponentInit', 
        { encodedTabIndex: SubTabEncodedEnum.Occupancy }
      );
      expect(component.occupancyForm).toBeDefined();
    }));
  });

  describe('Form Interactions', () => {
    beforeEach(fakeAsync(() => {
      initializeFormWithData();
      tick();
      fixture.detectChanges();
    }));

    it('should create form row with correct controls', () => {
      const row = component.createRow(createMockOccupancy());
      expect(row.get('LocationName').disabled).toBeTrue();
      expect(row.get('OccupancyGroup').validator).toBeTruthy();
    });

    it('should handle occupancy group change', fakeAsync(() => {
      const mockTypes = [{ value: 'type1', dependentValue: { hazard: 'h1', equipmentBreakdown: 'e1' } }];
      mockReToolService.getOccupancyType.and.returnValue(of(mockTypes));
      
      component.changeOccupancyGroup(0, '1');
      tick();
      
      const row = component.getFormArray().at(0);
      expect(row.get('OccupancyType').value).toBe(ReToolConstants.blank);
      expect(mockReToolService.getOccupancyType).toHaveBeenCalledWith('1');
    }));
  });

  describe('Form Validation', () => {
    it('should mark form invalid when required fields are empty', fakeAsync(() => {
      initializeFormWithData();
      tick();
      
      const row = component.getFormArray().at(0);
      row.get('OccupancyGroup').setValue('');
      row.get('OccupancyGroup').markAsTouched();
      component.occupancyForm.updateValueAndValidity();
      tick();
      
      expect(component.occupancyForm.invalid).toBeTrue();
      expect(mockReToolTabService.formStatus).toBe('INVALID');
    }));
  });

  // Helper functions and remaining tests remain the same as previous
  // ... [rest of the test code]
});

function createMockOccupancy(): Occupancy {
  return {
    ULId: '1',
    LocationName: 'Test Location',
    OccupancyGroup: '1',
    OccupancyType: 'type1',
    Hazard: 'h1',
    EquipmentBreakdown: 'e1',
    Action: ActionEnum.IsSaved
  };
}

function initializeFormWithData() {
  component.occupancyForm = fb.group({
    rows: fb.array([component.createRow(createMockOccupancy())])
  });
  component.occupancyDataSource = new MatTableDataSource(component.tableRowsControls);
}
